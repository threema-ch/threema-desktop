// WARNING: This file has been generated by safe-enums. Do not modify it!

import {type Logger} from './logging';
import {type u53} from './types';
import {type MonotonicEnumStore, type StoreDebug} from './utils/store';
export namespace TransferTag {
    export const PROXY = 0;
    // Builtin
    export type PROXY = typeof PROXY;
    export const THROW = 1;
    export type THROW = typeof THROW;
    export const TRANSFER_PROPERTIES = 2;
    // Object
    export type TRANSFER_PROPERTIES = typeof TRANSFER_PROPERTIES;
    export const STORE = 3;
    // Stores
    export type STORE = typeof STORE;
    export const MODEL_STORE = 4;
    export type MODEL_STORE = typeof MODEL_STORE;
    export const SET_STORE = 5;
    export type SET_STORE = typeof SET_STORE;
    export const ABORT_LISTENER = 6;
    // Events
    export type ABORT_LISTENER = typeof ABORT_LISTENER;
    export const BLOB_BACKEND_ERROR = 7;
    // Errors
    export type BLOB_BACKEND_ERROR = typeof BLOB_BACKEND_ERROR;
    export const CACHE_STORAGE_RESOURCE_CACHE_ERROR = 8;
    export type CACHE_STORAGE_RESOURCE_CACHE_ERROR = typeof CACHE_STORAGE_RESOURCE_CACHE_ERROR;
    export const CONNECTION_CLOSED_ERROR = 9;
    export type CONNECTION_CLOSED_ERROR = typeof CONNECTION_CLOSED_ERROR;
    export const CRYPTO_ERROR = 10;
    export type CRYPTO_ERROR = typeof CRYPTO_ERROR;
    export const DIRECTORY_ERROR = 11;
    export type DIRECTORY_ERROR = typeof DIRECTORY_ERROR;
    export const ENCODING_ERROR = 12;
    export type ENCODING_ERROR = typeof ENCODING_ERROR;
    export const FILE_STORAGE_ERROR = 13;
    export type FILE_STORAGE_ERROR = typeof FILE_STORAGE_ERROR;
    export const KEY_STORAGE_ERROR = 14;
    export type KEY_STORAGE_ERROR = typeof KEY_STORAGE_ERROR;
    export const INCOMING_REFLECTED_MESSAGE_TASK_ERROR = 15;
    export type INCOMING_REFLECTED_MESSAGE_TASK_ERROR =
        typeof INCOMING_REFLECTED_MESSAGE_TASK_ERROR;
    export const MIGRATION_ERROR = 16;
    export type MIGRATION_ERROR = typeof MIGRATION_ERROR;
    export const PROTOCOL_ERROR = 17;
    export type PROTOCOL_ERROR = typeof PROTOCOL_ERROR;
    export const TYPE_TRANSFORM_ERROR = 18;
    export type TYPE_TRANSFORM_ERROR = typeof TYPE_TRANSFORM_ERROR;
    export const COMPRESSION_ERROR = 19;
    export type COMPRESSION_ERROR = typeof COMPRESSION_ERROR;
    export const SAFE_ERROR = 20;
    export type SAFE_ERROR = typeof SAFE_ERROR;
    export const BACKEND_CREATION_ERROR = 21;
    export type BACKEND_CREATION_ERROR = typeof BACKEND_CREATION_ERROR;
    export const TASK_ERROR = 22;
    export type TASK_ERROR = typeof TASK_ERROR;
    export const RENDEZVOUS_PROTOCOL_ERROR = 23;
    export type RENDEZVOUS_PROTOCOL_ERROR = typeof RENDEZVOUS_PROTOCOL_ERROR;
    export const DEVICE_JOIN_PROTOCOL_ERROR = 24;
    export type DEVICE_JOIN_PROTOCOL_ERROR = typeof DEVICE_JOIN_PROTOCOL_ERROR;
    export const APPLICATION_STATE_ERROR = 25;
    export type APPLICATION_STATE_ERROR = typeof APPLICATION_STATE_ERROR;
    export const BLOB_FETCH_ERROR = 26;
    export type BLOB_FETCH_ERROR = typeof BLOB_FETCH_ERROR;
    export const WORK_ERROR = 27;
    export type WORK_ERROR = typeof WORK_ERROR;
    export const GROUP_CALL_ERROR = 28;
    export type GROUP_CALL_ERROR = typeof GROUP_CALL_ERROR;
    export const DELAYED_ERROR = 29;
    export type DELAYED_ERROR = typeof DELAYED_ERROR;
}
/**
 * All enums to be used must be declared in this file. They are disallowed in
 * any other place via an eslint rule.
 *
 * Use `npm run safe-enums:generate` to generate safer enum variants from them.
 *
 * Then, import the safe enum variant from `common/enum/index.ts`.
 *
 * Details on why standard enums in TypeScript are not type safe enough:
 *
 * - https://stackoverflow.com/a/55459814
 * - https://github.com/microsoft/TypeScript/issues/32690
 */
/**
 * ENDPOINT
 * ========
 */
/**
 * Available transfer handler tags.
 */
export type TransferTag = (typeof TransferTag)[keyof typeof TransferTag];
export namespace NonceScope {
    export const CSP = 0;
    export type CSP = typeof CSP;
    export const D2D = 1;
    export type D2D = typeof D2D;
}
/**
 * PROTOCOL
 * ========
 */
/**
 * Nonce scopes. Defines in which context a nonce must be unique.
 *
 * @generate convert
 */
export type NonceScope = (typeof NonceScope)[keyof typeof NonceScope];
export namespace NonceScopeUtils {
    export const ALL: ReadonlySet<NonceScope> = new Set([NonceScope.CSP, NonceScope.D2D] as const);
    export function fromNumber(value: u53, fallback?: NonceScope): NonceScope {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as NonceScope;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid NonceScope`);
    }
    export function containsNumber(value: u53): value is NonceScope {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is NonceScope {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace CloseCode {
    export const NORMAL = 1000;
    /** Normal closure, e.g. when the user is explicitly disconnecting. */
    export type NORMAL = typeof NORMAL;
    export const SERVER_SHUTDOWN = 1001;
    /** Server is shutting down or browser is navigating away. */
    export type SERVER_SHUTDOWN = typeof SERVER_SHUTDOWN;
    export const ABNORMAL_CLOSURE = 1006;
    /** Connection was closed without receiving a close frame. */
    export type ABNORMAL_CLOSURE = typeof ABNORMAL_CLOSURE;
    export const CSP_CLOSED = 4000;
    /** Chat server connection closed. */
    export type CSP_CLOSED = typeof CSP_CLOSED;
    export const CSP_UNABLE_TO_ESTABLISH = 4001;
    /** Chat server connection could not be established. */
    export type CSP_UNABLE_TO_ESTABLISH = typeof CSP_UNABLE_TO_ESTABLISH;
    export const CSP_INTERNAL_ERROR = 4009;
    /** Internal error related to chat server connection. */
    export type CSP_INTERNAL_ERROR = typeof CSP_INTERNAL_ERROR;
    export const PROTOCOL_ERROR = 4010;
    /** Protocol error. */
    export type PROTOCOL_ERROR = typeof PROTOCOL_ERROR;
    export const TRANSACTION_TTL_EXCEEDED = 4011;
    /** Transaction TTL exceeded. */
    export type TRANSACTION_TTL_EXCEEDED = typeof TRANSACTION_TTL_EXCEEDED;
    export const UNEXPECTED_ACK = 4012;
    /** Unexpected acknowledgement was received by the server. */
    export type UNEXPECTED_ACK = typeof UNEXPECTED_ACK;
    export const CLIENT_TIMEOUT = 4013;
    /** Client considered the connection to be timed out. */
    export type CLIENT_TIMEOUT = typeof CLIENT_TIMEOUT;
    export const UNSUPPORTED_PROTOCOL_VERSION = 4110;
    /** Unsupported protocol version. */
    export type UNSUPPORTED_PROTOCOL_VERSION = typeof UNSUPPORTED_PROTOCOL_VERSION;
    export const DEVICE_LIMIT_REACHED = 4111;
    /** Device limit reached. */
    export type DEVICE_LIMIT_REACHED = typeof DEVICE_LIMIT_REACHED;
    export const DEVICE_ID_REUSED = 4112;
    /**
     * Device id was used for another connection.
     *
     * Note: It is fine to ignore this in connections that are currently closing.
     */
    export type DEVICE_ID_REUSED = typeof DEVICE_ID_REUSED;
    export const DEVICE_DROPPED = 4113;
    /** Dropped by another device. */
    export type DEVICE_DROPPED = typeof DEVICE_DROPPED;
    export const REFLECTION_QUEUE_LENGTH_LIMIT_REACHED = 4114;
    /** Reflection queue length limit reached (device data was deleted on mediator server). */
    export type REFLECTION_QUEUE_LENGTH_LIMIT_REACHED =
        typeof REFLECTION_QUEUE_LENGTH_LIMIT_REACHED;
    export const EXPECTED_DEVICE_SLOT_STATE_MISMATCH = 4115;
    /** Expected device slot state mismatch. */
    export type EXPECTED_DEVICE_SLOT_STATE_MISMATCH = typeof EXPECTED_DEVICE_SLOT_STATE_MISMATCH;
    export const INTERNAL_ERROR = 5000;
    /** Internal client error. */
    export type INTERNAL_ERROR = typeof INTERNAL_ERROR;
    export const WEBSOCKET_UNABLE_TO_ESTABLISH = 5001;
    /** Web socket connection could not be established. */
    export type WEBSOCKET_UNABLE_TO_ESTABLISH = typeof WEBSOCKET_UNABLE_TO_ESTABLISH;
}
/**
 * WebSocket close code, extended by the Mediator Protocol 4xxx custom close
 * codes.
 *
 * @generate name convert
 */
export type CloseCode = (typeof CloseCode)[keyof typeof CloseCode];
export namespace CloseCodeUtils {
    export const ALL: ReadonlySet<CloseCode> = new Set([
        CloseCode.NORMAL,
        CloseCode.SERVER_SHUTDOWN,
        CloseCode.ABNORMAL_CLOSURE,
        CloseCode.CSP_CLOSED,
        CloseCode.CSP_UNABLE_TO_ESTABLISH,
        CloseCode.CSP_INTERNAL_ERROR,
        CloseCode.PROTOCOL_ERROR,
        CloseCode.TRANSACTION_TTL_EXCEEDED,
        CloseCode.UNEXPECTED_ACK,
        CloseCode.CLIENT_TIMEOUT,
        CloseCode.UNSUPPORTED_PROTOCOL_VERSION,
        CloseCode.DEVICE_LIMIT_REACHED,
        CloseCode.DEVICE_ID_REUSED,
        CloseCode.DEVICE_DROPPED,
        CloseCode.REFLECTION_QUEUE_LENGTH_LIMIT_REACHED,
        CloseCode.EXPECTED_DEVICE_SLOT_STATE_MISMATCH,
        CloseCode.INTERNAL_ERROR,
        CloseCode.WEBSOCKET_UNABLE_TO_ESTABLISH,
    ] as const);
    export function fromNumber(value: u53, fallback?: CloseCode): CloseCode {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as CloseCode;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid CloseCode`);
    }
    export function containsNumber(value: u53): value is CloseCode {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is CloseCode {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
    export const NAME_OF = {
        [CloseCode.NORMAL]: 'NORMAL',
        [CloseCode.SERVER_SHUTDOWN]: 'SERVER_SHUTDOWN',
        [CloseCode.ABNORMAL_CLOSURE]: 'ABNORMAL_CLOSURE',
        [CloseCode.CSP_CLOSED]: 'CSP_CLOSED',
        [CloseCode.CSP_UNABLE_TO_ESTABLISH]: 'CSP_UNABLE_TO_ESTABLISH',
        [CloseCode.CSP_INTERNAL_ERROR]: 'CSP_INTERNAL_ERROR',
        [CloseCode.PROTOCOL_ERROR]: 'PROTOCOL_ERROR',
        [CloseCode.TRANSACTION_TTL_EXCEEDED]: 'TRANSACTION_TTL_EXCEEDED',
        [CloseCode.UNEXPECTED_ACK]: 'UNEXPECTED_ACK',
        [CloseCode.CLIENT_TIMEOUT]: 'CLIENT_TIMEOUT',
        [CloseCode.UNSUPPORTED_PROTOCOL_VERSION]: 'UNSUPPORTED_PROTOCOL_VERSION',
        [CloseCode.DEVICE_LIMIT_REACHED]: 'DEVICE_LIMIT_REACHED',
        [CloseCode.DEVICE_ID_REUSED]: 'DEVICE_ID_REUSED',
        [CloseCode.DEVICE_DROPPED]: 'DEVICE_DROPPED',
        [CloseCode.REFLECTION_QUEUE_LENGTH_LIMIT_REACHED]: 'REFLECTION_QUEUE_LENGTH_LIMIT_REACHED',
        [CloseCode.EXPECTED_DEVICE_SLOT_STATE_MISMATCH]: 'EXPECTED_DEVICE_SLOT_STATE_MISMATCH',
        [CloseCode.INTERNAL_ERROR]: 'INTERNAL_ERROR',
        [CloseCode.WEBSOCKET_UNABLE_TO_ESTABLISH]: 'WEBSOCKET_UNABLE_TO_ESTABLISH',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace RendezvousCloseCode {
    export const NORMAL = 1000;
    // Builtin close codes
    /** Normal closure, e.g. when the user is explicitly disconnecting. */
    export type NORMAL = typeof NORMAL;
    export const RENDEZVOUS_PROTOCOL_ERROR = 4000;
    // Server <-> Client
    /** Rendezvous protocol error. */
    export type RENDEZVOUS_PROTOCOL_ERROR = typeof RENDEZVOUS_PROTOCOL_ERROR;
    export const INIT_TIMEOUT_REACHED = 4003;
    /** Init timeout reached, other device did not connect. */
    export type INIT_TIMEOUT_REACHED = typeof INIT_TIMEOUT_REACHED;
    export const OTHER_DEVICE_DISCONNECTED = 4004;
    /** Other device disconnected without reflectable close code. */
    export type OTHER_DEVICE_DISCONNECTED = typeof OTHER_DEVICE_DISCONNECTED;
    export const ULP_ERROR = 4100;
    // Client <-> Client
    /** Upper Layer Protocol error. */
    export type ULP_ERROR = typeof ULP_ERROR;
}
/**
 * WebSocket close code, extended by the Rendezvous Protocol 4xxx custom close
 * codes.
 *
 * @generate name convert
 */
export type RendezvousCloseCode = (typeof RendezvousCloseCode)[keyof typeof RendezvousCloseCode];
export namespace RendezvousCloseCodeUtils {
    export const ALL: ReadonlySet<RendezvousCloseCode> = new Set([
        RendezvousCloseCode.NORMAL,
        RendezvousCloseCode.RENDEZVOUS_PROTOCOL_ERROR,
        RendezvousCloseCode.INIT_TIMEOUT_REACHED,
        RendezvousCloseCode.OTHER_DEVICE_DISCONNECTED,
        RendezvousCloseCode.ULP_ERROR,
    ] as const);
    export function fromNumber(value: u53, fallback?: RendezvousCloseCode): RendezvousCloseCode {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as RendezvousCloseCode;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid RendezvousCloseCode`);
    }
    export function containsNumber(value: u53): value is RendezvousCloseCode {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is RendezvousCloseCode {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
    export const NAME_OF = {
        [RendezvousCloseCode.NORMAL]: 'NORMAL',
        [RendezvousCloseCode.RENDEZVOUS_PROTOCOL_ERROR]: 'RENDEZVOUS_PROTOCOL_ERROR',
        [RendezvousCloseCode.INIT_TIMEOUT_REACHED]: 'INIT_TIMEOUT_REACHED',
        [RendezvousCloseCode.OTHER_DEVICE_DISCONNECTED]: 'OTHER_DEVICE_DISCONNECTED',
        [RendezvousCloseCode.ULP_ERROR]: 'ULP_ERROR',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace ConnectionState {
    export const CONNECTING = 0;
    export type CONNECTING = typeof CONNECTING;
    export const HANDSHAKE = 1;
    export type HANDSHAKE = typeof HANDSHAKE;
    export const PARTIALLY_CONNECTED = 2;
    export type PARTIALLY_CONNECTED = typeof PARTIALLY_CONNECTED;
    export const CONNECTED = 3;
    export type CONNECTED = typeof CONNECTED;
    export const DISCONNECTED = 4;
    export type DISCONNECTED = typeof DISCONNECTED;
}
/**
 * Combined connection state towards the Mediator server and the Chat server.
 *
 * @generate name store
 */
export type ConnectionState = (typeof ConnectionState)[keyof typeof ConnectionState];
export namespace ConnectionStateUtils {
    export const NAME_OF = {
        [ConnectionState.CONNECTING]: 'CONNECTING',
        [ConnectionState.HANDSHAKE]: 'HANDSHAKE',
        [ConnectionState.PARTIALLY_CONNECTED]: 'PARTIALLY_CONNECTED',
        [ConnectionState.CONNECTED]: 'CONNECTED',
        [ConnectionState.DISCONNECTED]: 'DISCONNECTED',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
    export function createStore<S extends MonotonicEnumStore<ConnectionState>>(
        constructor: new (
            initial: ConnectionState,
            activator?: undefined,
            debug?: StoreDebug<ConnectionState>,
        ) => S,
        initial: ConnectionState,
        debug?: {
            log: Logger;
            tag: string;
        },
    ): S {
        return new constructor(
            initial,
            undefined,
            debug === undefined
                ? undefined
                : {
                      log: debug.log,
                      tag: debug.tag,
                      representation: (name): string => NAME_OF[name],
                  },
        );
    }
}
export namespace CspAuthState {
    export const CLIENT_HELLO = 0;
    export type CLIENT_HELLO = typeof CLIENT_HELLO;
    export const SERVER_HELLO = 1;
    export type SERVER_HELLO = typeof SERVER_HELLO;
    export const LOGIN_ACK = 2;
    export type LOGIN_ACK = typeof LOGIN_ACK;
    export const COMPLETE = 3;
    export type COMPLETE = typeof COMPLETE;
}
/**
 * Chat server protocol authentication state.
 *
 * @generate name
 */
export type CspAuthState = (typeof CspAuthState)[keyof typeof CspAuthState];
export namespace CspAuthStateUtils {
    export const NAME_OF = {
        [CspAuthState.CLIENT_HELLO]: 'CLIENT_HELLO',
        [CspAuthState.SERVER_HELLO]: 'SERVER_HELLO',
        [CspAuthState.LOGIN_ACK]: 'LOGIN_ACK',
        [CspAuthState.COMPLETE]: 'COMPLETE',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace D2mAuthState {
    export const SERVER_HELLO = 0;
    export type SERVER_HELLO = typeof SERVER_HELLO;
    export const COMPLETE = 1;
    export type COMPLETE = typeof COMPLETE;
}
/**
 * Mediator protocol authentication state.
 *
 * @generate name
 */
export type D2mAuthState = (typeof D2mAuthState)[keyof typeof D2mAuthState];
export namespace D2mAuthStateUtils {
    export const NAME_OF = {
        [D2mAuthState.SERVER_HELLO]: 'SERVER_HELLO',
        [D2mAuthState.COMPLETE]: 'COMPLETE',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace D2mLeaderState {
    export const NONLEADER = 0;
    export type NONLEADER = typeof NONLEADER;
    export const LEADER = 1;
    export type LEADER = typeof LEADER;
}
/**
 * Mediator leader state.
 *
 * @generate name store
 */
export type D2mLeaderState = (typeof D2mLeaderState)[keyof typeof D2mLeaderState];
export namespace D2mLeaderStateUtils {
    export const NAME_OF = {
        [D2mLeaderState.NONLEADER]: 'NONLEADER',
        [D2mLeaderState.LEADER]: 'LEADER',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
    export function createStore<S extends MonotonicEnumStore<D2mLeaderState>>(
        constructor: new (
            initial: D2mLeaderState,
            activator?: undefined,
            debug?: StoreDebug<D2mLeaderState>,
        ) => S,
        initial: D2mLeaderState,
        debug?: {
            log: Logger;
            tag: string;
        },
    ): S {
        return new constructor(
            initial,
            undefined,
            debug === undefined
                ? undefined
                : {
                      log: debug.log,
                      tag: debug.tag,
                      representation: (name): string => NAME_OF[name],
                  },
        );
    }
}
export namespace D2mPayloadType {
    export const PROXY = 0;
    export type PROXY = typeof PROXY;
    export const SERVER_HELLO = 16;
    export type SERVER_HELLO = typeof SERVER_HELLO;
    export const CLIENT_HELLO = 17;
    export type CLIENT_HELLO = typeof CLIENT_HELLO;
    export const SERVER_INFO = 18;
    export type SERVER_INFO = typeof SERVER_INFO;
    export const REFLECTION_QUEUE_DRY = 32;
    export type REFLECTION_QUEUE_DRY = typeof REFLECTION_QUEUE_DRY;
    export const ROLE_PROMOTED_TO_LEADER = 33;
    export type ROLE_PROMOTED_TO_LEADER = typeof ROLE_PROMOTED_TO_LEADER;
    export const GET_DEVICES_INFO = 48;
    export type GET_DEVICES_INFO = typeof GET_DEVICES_INFO;
    export const DEVICES_INFO = 49;
    export type DEVICES_INFO = typeof DEVICES_INFO;
    export const DROP_DEVICE = 50;
    export type DROP_DEVICE = typeof DROP_DEVICE;
    export const DROP_DEVICE_ACK = 51;
    export type DROP_DEVICE_ACK = typeof DROP_DEVICE_ACK;
    export const SET_SHARED_DEVICE_DATA = 52;
    export type SET_SHARED_DEVICE_DATA = typeof SET_SHARED_DEVICE_DATA;
    export const BEGIN_TRANSACTION = 64;
    export type BEGIN_TRANSACTION = typeof BEGIN_TRANSACTION;
    export const BEGIN_TRANSACTION_ACK = 65;
    export type BEGIN_TRANSACTION_ACK = typeof BEGIN_TRANSACTION_ACK;
    export const COMMIT_TRANSACTION = 66;
    export type COMMIT_TRANSACTION = typeof COMMIT_TRANSACTION;
    export const COMMIT_TRANSACTION_ACK = 67;
    export type COMMIT_TRANSACTION_ACK = typeof COMMIT_TRANSACTION_ACK;
    export const TRANSACTION_REJECTED = 68;
    export type TRANSACTION_REJECTED = typeof TRANSACTION_REJECTED;
    export const TRANSACTION_ENDED = 69;
    export type TRANSACTION_ENDED = typeof TRANSACTION_ENDED;
    export const REFLECT = 128;
    export type REFLECT = typeof REFLECT;
    export const REFLECT_ACK = 129;
    export type REFLECT_ACK = typeof REFLECT_ACK;
    export const REFLECTED = 130;
    export type REFLECTED = typeof REFLECTED;
    export const REFLECTED_ACK = 131;
    export type REFLECTED_ACK = typeof REFLECTED_ACK;
}
/**
 * Device to mediator protocol payload type.
 *
 * @generate name
 */
export type D2mPayloadType = (typeof D2mPayloadType)[keyof typeof D2mPayloadType];
export namespace D2mPayloadTypeUtils {
    export const NAME_OF = {
        [D2mPayloadType.PROXY]: 'PROXY',
        [D2mPayloadType.SERVER_HELLO]: 'SERVER_HELLO',
        [D2mPayloadType.CLIENT_HELLO]: 'CLIENT_HELLO',
        [D2mPayloadType.SERVER_INFO]: 'SERVER_INFO',
        [D2mPayloadType.REFLECTION_QUEUE_DRY]: 'REFLECTION_QUEUE_DRY',
        [D2mPayloadType.ROLE_PROMOTED_TO_LEADER]: 'ROLE_PROMOTED_TO_LEADER',
        [D2mPayloadType.GET_DEVICES_INFO]: 'GET_DEVICES_INFO',
        [D2mPayloadType.DEVICES_INFO]: 'DEVICES_INFO',
        [D2mPayloadType.DROP_DEVICE]: 'DROP_DEVICE',
        [D2mPayloadType.DROP_DEVICE_ACK]: 'DROP_DEVICE_ACK',
        [D2mPayloadType.SET_SHARED_DEVICE_DATA]: 'SET_SHARED_DEVICE_DATA',
        [D2mPayloadType.BEGIN_TRANSACTION]: 'BEGIN_TRANSACTION',
        [D2mPayloadType.BEGIN_TRANSACTION_ACK]: 'BEGIN_TRANSACTION_ACK',
        [D2mPayloadType.COMMIT_TRANSACTION]: 'COMMIT_TRANSACTION',
        [D2mPayloadType.COMMIT_TRANSACTION_ACK]: 'COMMIT_TRANSACTION_ACK',
        [D2mPayloadType.TRANSACTION_REJECTED]: 'TRANSACTION_REJECTED',
        [D2mPayloadType.TRANSACTION_ENDED]: 'TRANSACTION_ENDED',
        [D2mPayloadType.REFLECT]: 'REFLECT',
        [D2mPayloadType.REFLECT_ACK]: 'REFLECT_ACK',
        [D2mPayloadType.REFLECTED]: 'REFLECTED',
        [D2mPayloadType.REFLECTED_ACK]: 'REFLECTED_ACK',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace CspExtensionType {
    export const CLIENT_INFO = 0;
    export type CLIENT_INFO = typeof CLIENT_INFO;
    export const CSP_DEVICE_ID = 1;
    export type CSP_DEVICE_ID = typeof CSP_DEVICE_ID;
    export const MESSAGE_PAYLOAD_VERSION = 2;
    export type MESSAGE_PAYLOAD_VERSION = typeof MESSAGE_PAYLOAD_VERSION;
    export const DEVICE_COOKIE = 3;
    export type DEVICE_COOKIE = typeof DEVICE_COOKIE;
}
/**
 * Chat server protocol 'clever extension' type.
 */
export type CspExtensionType = (typeof CspExtensionType)[keyof typeof CspExtensionType];
export namespace CspMessagePayloadVersion {
    export const LEGACY_MESSAGE = 0;
    export type LEGACY_MESSAGE = typeof LEGACY_MESSAGE;
    export const MESSAGE_WITH_METADATA_BOX = 1;
    export type MESSAGE_WITH_METADATA_BOX = typeof MESSAGE_WITH_METADATA_BOX;
}
/**
 * CSP message payload struct version to be used.
 */
export type CspMessagePayloadVersion =
    (typeof CspMessagePayloadVersion)[keyof typeof CspMessagePayloadVersion];
export namespace CspPayloadType {
    export const ECHO_REQUEST = 0;
    export type ECHO_REQUEST = typeof ECHO_REQUEST;
    export const ECHO_RESPONSE = 128;
    export type ECHO_RESPONSE = typeof ECHO_RESPONSE;
    export const OUTGOING_MESSAGE = 1;
    export type OUTGOING_MESSAGE = typeof OUTGOING_MESSAGE;
    export const OUTGOING_MESSAGE_ACK = 129;
    export type OUTGOING_MESSAGE_ACK = typeof OUTGOING_MESSAGE_ACK;
    export const INCOMING_MESSAGE = 2;
    export type INCOMING_MESSAGE = typeof INCOMING_MESSAGE;
    export const INCOMING_MESSAGE_ACK = 130;
    export type INCOMING_MESSAGE_ACK = typeof INCOMING_MESSAGE_ACK;
    export const UNBLOCK_INCOMING_MESSAGES = 3;
    export type UNBLOCK_INCOMING_MESSAGES = typeof UNBLOCK_INCOMING_MESSAGES;
    export const SET_CONNECTION_IDLE_TIMEOUT = 48;
    export type SET_CONNECTION_IDLE_TIMEOUT = typeof SET_CONNECTION_IDLE_TIMEOUT;
    export const QUEUE_SEND_COMPLETE = 208;
    export type QUEUE_SEND_COMPLETE = typeof QUEUE_SEND_COMPLETE;
    export const LAST_EPHEMERAL_KEY_HASH = 209;
    export type LAST_EPHEMERAL_KEY_HASH = typeof LAST_EPHEMERAL_KEY_HASH;
    export const CLOSE_ERROR = 224;
    export type CLOSE_ERROR = typeof CLOSE_ERROR;
    export const ALERT = 225;
    export type ALERT = typeof ALERT;
    export const DEVICE_COOKIE_CHANGED_INDICATION = 210;
    export type DEVICE_COOKIE_CHANGED_INDICATION = typeof DEVICE_COOKIE_CHANGED_INDICATION;
    export const CLEAR_DEVICE_COOKIE_CHANGED_INDICATION = 211;
    export type CLEAR_DEVICE_COOKIE_CHANGED_INDICATION =
        typeof CLEAR_DEVICE_COOKIE_CHANGED_INDICATION;
}
/**
 * Chat server protocol payload type.
 *
 * @generate name
 */
export type CspPayloadType = (typeof CspPayloadType)[keyof typeof CspPayloadType];
export namespace CspPayloadTypeUtils {
    export const NAME_OF = {
        [CspPayloadType.ECHO_REQUEST]: 'ECHO_REQUEST',
        [CspPayloadType.ECHO_RESPONSE]: 'ECHO_RESPONSE',
        [CspPayloadType.OUTGOING_MESSAGE]: 'OUTGOING_MESSAGE',
        [CspPayloadType.OUTGOING_MESSAGE_ACK]: 'OUTGOING_MESSAGE_ACK',
        [CspPayloadType.INCOMING_MESSAGE]: 'INCOMING_MESSAGE',
        [CspPayloadType.INCOMING_MESSAGE_ACK]: 'INCOMING_MESSAGE_ACK',
        [CspPayloadType.UNBLOCK_INCOMING_MESSAGES]: 'UNBLOCK_INCOMING_MESSAGES',
        [CspPayloadType.SET_CONNECTION_IDLE_TIMEOUT]: 'SET_CONNECTION_IDLE_TIMEOUT',
        [CspPayloadType.QUEUE_SEND_COMPLETE]: 'QUEUE_SEND_COMPLETE',
        [CspPayloadType.LAST_EPHEMERAL_KEY_HASH]: 'LAST_EPHEMERAL_KEY_HASH',
        [CspPayloadType.CLOSE_ERROR]: 'CLOSE_ERROR',
        [CspPayloadType.ALERT]: 'ALERT',
        [CspPayloadType.DEVICE_COOKIE_CHANGED_INDICATION]: 'DEVICE_COOKIE_CHANGED_INDICATION',
        [CspPayloadType.CLEAR_DEVICE_COOKIE_CHANGED_INDICATION]:
            'CLEAR_DEVICE_COOKIE_CHANGED_INDICATION',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace CspMessageFlag {
    export const NONE = 0;
    export type NONE = typeof NONE;
    export const SEND_PUSH_NOTIFICATION = 1;
    export type SEND_PUSH_NOTIFICATION = typeof SEND_PUSH_NOTIFICATION;
    export const DONT_QUEUE = 2;
    export type DONT_QUEUE = typeof DONT_QUEUE;
    export const DONT_ACK = 4;
    export type DONT_ACK = typeof DONT_ACK;
    export const GROUP_MESSAGE = 16;
    export type GROUP_MESSAGE = typeof GROUP_MESSAGE;
    export const IMMEDIATE_DELIVERY_REQUIRED = 32;
    export type IMMEDIATE_DELIVERY_REQUIRED = typeof IMMEDIATE_DELIVERY_REQUIRED;
    export const DONT_SEND_DELIVERY_RECEIPTS = 128;
    export type DONT_SEND_DELIVERY_RECEIPTS = typeof DONT_SEND_DELIVERY_RECEIPTS;
}
/**
 * Chat server protocol message flag.
 */
export type CspMessageFlag = (typeof CspMessageFlag)[keyof typeof CspMessageFlag];
export namespace CspE2eConversationType {
    export const TEXT = 1;
    export type TEXT = typeof TEXT;
    export const DEPRECATED_IMAGE = 2;
    export type DEPRECATED_IMAGE = typeof DEPRECATED_IMAGE;
    export const LOCATION = 16;
    export type LOCATION = typeof LOCATION;
    export const DEPRECATED_AUDIO = 20;
    export type DEPRECATED_AUDIO = typeof DEPRECATED_AUDIO;
    export const DEPRECATED_VIDEO = 19;
    export type DEPRECATED_VIDEO = typeof DEPRECATED_VIDEO;
    export const FILE = 23;
    export type FILE = typeof FILE;
    export const POLL_SETUP = 21;
    export type POLL_SETUP = typeof POLL_SETUP;
    export const POLL_VOTE = 22;
    export type POLL_VOTE = typeof POLL_VOTE;
    export const CALL_OFFER = 96;
    export type CALL_OFFER = typeof CALL_OFFER;
    export const CALL_ANSWER = 97;
    export type CALL_ANSWER = typeof CALL_ANSWER;
    export const CALL_ICE_CANDIDATE = 98;
    export type CALL_ICE_CANDIDATE = typeof CALL_ICE_CANDIDATE;
    export const CALL_HANGUP = 99;
    export type CALL_HANGUP = typeof CALL_HANGUP;
    export const CALL_RINGING = 100;
    export type CALL_RINGING = typeof CALL_RINGING;
}
/**
 * E2EE 1:1 conversation message type.
 *
 * @generate name convert
 */
export type CspE2eConversationType =
    (typeof CspE2eConversationType)[keyof typeof CspE2eConversationType];
export namespace CspE2eConversationTypeUtils {
    export const ALL: ReadonlySet<CspE2eConversationType> = new Set([
        CspE2eConversationType.TEXT,
        CspE2eConversationType.DEPRECATED_IMAGE,
        CspE2eConversationType.LOCATION,
        CspE2eConversationType.DEPRECATED_AUDIO,
        CspE2eConversationType.DEPRECATED_VIDEO,
        CspE2eConversationType.FILE,
        CspE2eConversationType.POLL_SETUP,
        CspE2eConversationType.POLL_VOTE,
        CspE2eConversationType.CALL_OFFER,
        CspE2eConversationType.CALL_ANSWER,
        CspE2eConversationType.CALL_ICE_CANDIDATE,
        CspE2eConversationType.CALL_HANGUP,
        CspE2eConversationType.CALL_RINGING,
    ] as const);
    export function fromNumber(
        value: u53,
        fallback?: CspE2eConversationType,
    ): CspE2eConversationType {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as CspE2eConversationType;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid CspE2eConversationType`);
    }
    export function containsNumber(value: u53): value is CspE2eConversationType {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is CspE2eConversationType {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
    export const NAME_OF = {
        [CspE2eConversationType.TEXT]: 'TEXT',
        [CspE2eConversationType.DEPRECATED_IMAGE]: 'DEPRECATED_IMAGE',
        [CspE2eConversationType.LOCATION]: 'LOCATION',
        [CspE2eConversationType.DEPRECATED_AUDIO]: 'DEPRECATED_AUDIO',
        [CspE2eConversationType.DEPRECATED_VIDEO]: 'DEPRECATED_VIDEO',
        [CspE2eConversationType.FILE]: 'FILE',
        [CspE2eConversationType.POLL_SETUP]: 'POLL_SETUP',
        [CspE2eConversationType.POLL_VOTE]: 'POLL_VOTE',
        [CspE2eConversationType.CALL_OFFER]: 'CALL_OFFER',
        [CspE2eConversationType.CALL_ANSWER]: 'CALL_ANSWER',
        [CspE2eConversationType.CALL_ICE_CANDIDATE]: 'CALL_ICE_CANDIDATE',
        [CspE2eConversationType.CALL_HANGUP]: 'CALL_HANGUP',
        [CspE2eConversationType.CALL_RINGING]: 'CALL_RINGING',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace CspE2eStatusUpdateType {
    export const DELIVERY_RECEIPT = 128;
    export type DELIVERY_RECEIPT = typeof DELIVERY_RECEIPT;
    export const TYPING_INDICATOR = 144;
    export type TYPING_INDICATOR = typeof TYPING_INDICATOR;
}
/**
 * E2EE 1:1 status update type.
 *
 * @generate name
 */
export type CspE2eStatusUpdateType =
    (typeof CspE2eStatusUpdateType)[keyof typeof CspE2eStatusUpdateType];
export namespace CspE2eStatusUpdateTypeUtils {
    export const NAME_OF = {
        [CspE2eStatusUpdateType.DELIVERY_RECEIPT]: 'DELIVERY_RECEIPT',
        [CspE2eStatusUpdateType.TYPING_INDICATOR]: 'TYPING_INDICATOR',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace CspE2eContactControlType {
    export const CONTACT_SET_PROFILE_PICTURE = 24;
    export type CONTACT_SET_PROFILE_PICTURE = typeof CONTACT_SET_PROFILE_PICTURE;
    export const CONTACT_DELETE_PROFILE_PICTURE = 25;
    export type CONTACT_DELETE_PROFILE_PICTURE = typeof CONTACT_DELETE_PROFILE_PICTURE;
    export const CONTACT_REQUEST_PROFILE_PICTURE = 26;
    export type CONTACT_REQUEST_PROFILE_PICTURE = typeof CONTACT_REQUEST_PROFILE_PICTURE;
}
/**
 * E2EE contact control type.
 *
 * @generate name
 */
export type CspE2eContactControlType =
    (typeof CspE2eContactControlType)[keyof typeof CspE2eContactControlType];
export namespace CspE2eContactControlTypeUtils {
    export const NAME_OF = {
        [CspE2eContactControlType.CONTACT_SET_PROFILE_PICTURE]: 'CONTACT_SET_PROFILE_PICTURE',
        [CspE2eContactControlType.CONTACT_DELETE_PROFILE_PICTURE]: 'CONTACT_DELETE_PROFILE_PICTURE',
        [CspE2eContactControlType.CONTACT_REQUEST_PROFILE_PICTURE]:
            'CONTACT_REQUEST_PROFILE_PICTURE',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace CspE2eGroupConversationType {
    export const GROUP_TEXT = 65;
    export type GROUP_TEXT = typeof GROUP_TEXT;
    export const GROUP_LOCATION = 66;
    export type GROUP_LOCATION = typeof GROUP_LOCATION;
    export const DEPRECATED_GROUP_IMAGE = 67;
    export type DEPRECATED_GROUP_IMAGE = typeof DEPRECATED_GROUP_IMAGE;
    export const GROUP_AUDIO = 69;
    export type GROUP_AUDIO = typeof GROUP_AUDIO;
    export const GROUP_VIDEO = 68;
    export type GROUP_VIDEO = typeof GROUP_VIDEO;
    export const GROUP_FILE = 70;
    export type GROUP_FILE = typeof GROUP_FILE;
    export const GROUP_POLL_SETUP = 82;
    export type GROUP_POLL_SETUP = typeof GROUP_POLL_SETUP;
    export const GROUP_POLL_VOTE = 83;
    export type GROUP_POLL_VOTE = typeof GROUP_POLL_VOTE;
}
/**
 * E2EE group conversation type.
 *
 * @generate name convert
 */
export type CspE2eGroupConversationType =
    (typeof CspE2eGroupConversationType)[keyof typeof CspE2eGroupConversationType];
export namespace CspE2eGroupConversationTypeUtils {
    export const ALL: ReadonlySet<CspE2eGroupConversationType> = new Set([
        CspE2eGroupConversationType.GROUP_TEXT,
        CspE2eGroupConversationType.GROUP_LOCATION,
        CspE2eGroupConversationType.DEPRECATED_GROUP_IMAGE,
        CspE2eGroupConversationType.GROUP_AUDIO,
        CspE2eGroupConversationType.GROUP_VIDEO,
        CspE2eGroupConversationType.GROUP_FILE,
        CspE2eGroupConversationType.GROUP_POLL_SETUP,
        CspE2eGroupConversationType.GROUP_POLL_VOTE,
    ] as const);
    export function fromNumber(
        value: u53,
        fallback?: CspE2eGroupConversationType,
    ): CspE2eGroupConversationType {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as CspE2eGroupConversationType;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid CspE2eGroupConversationType`);
    }
    export function containsNumber(value: u53): value is CspE2eGroupConversationType {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is CspE2eGroupConversationType {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
    export const NAME_OF = {
        [CspE2eGroupConversationType.GROUP_TEXT]: 'GROUP_TEXT',
        [CspE2eGroupConversationType.GROUP_LOCATION]: 'GROUP_LOCATION',
        [CspE2eGroupConversationType.DEPRECATED_GROUP_IMAGE]: 'DEPRECATED_GROUP_IMAGE',
        [CspE2eGroupConversationType.GROUP_AUDIO]: 'GROUP_AUDIO',
        [CspE2eGroupConversationType.GROUP_VIDEO]: 'GROUP_VIDEO',
        [CspE2eGroupConversationType.GROUP_FILE]: 'GROUP_FILE',
        [CspE2eGroupConversationType.GROUP_POLL_SETUP]: 'GROUP_POLL_SETUP',
        [CspE2eGroupConversationType.GROUP_POLL_VOTE]: 'GROUP_POLL_VOTE',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace CspE2eGroupStatusUpdateType {
    export const GROUP_DELIVERY_RECEIPT = 129;
    export type GROUP_DELIVERY_RECEIPT = typeof GROUP_DELIVERY_RECEIPT;
}
/**
 * E2EE group status update type.
 *
 * @generate name
 */
export type CspE2eGroupStatusUpdateType =
    (typeof CspE2eGroupStatusUpdateType)[keyof typeof CspE2eGroupStatusUpdateType];
export namespace CspE2eGroupStatusUpdateTypeUtils {
    export const NAME_OF = {
        [CspE2eGroupStatusUpdateType.GROUP_DELIVERY_RECEIPT]: 'GROUP_DELIVERY_RECEIPT',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace CspE2eGroupControlType {
    export const GROUP_SETUP = 74;
    export type GROUP_SETUP = typeof GROUP_SETUP;
    export const GROUP_NAME = 75;
    export type GROUP_NAME = typeof GROUP_NAME;
    export const GROUP_LEAVE = 76;
    export type GROUP_LEAVE = typeof GROUP_LEAVE;
    export const GROUP_SET_PROFILE_PICTURE = 80;
    export type GROUP_SET_PROFILE_PICTURE = typeof GROUP_SET_PROFILE_PICTURE;
    export const GROUP_DELETE_PROFILE_PICTURE = 84;
    export type GROUP_DELETE_PROFILE_PICTURE = typeof GROUP_DELETE_PROFILE_PICTURE;
    export const GROUP_SYNC_REQUEST = 81;
    export type GROUP_SYNC_REQUEST = typeof GROUP_SYNC_REQUEST;
    export const GROUP_CALL_START = 79;
    export type GROUP_CALL_START = typeof GROUP_CALL_START;
}
/**
 * E2EE group control type.
 *
 * @generate name convert
 */
export type CspE2eGroupControlType =
    (typeof CspE2eGroupControlType)[keyof typeof CspE2eGroupControlType];
export namespace CspE2eGroupControlTypeUtils {
    export const ALL: ReadonlySet<CspE2eGroupControlType> = new Set([
        CspE2eGroupControlType.GROUP_SETUP,
        CspE2eGroupControlType.GROUP_NAME,
        CspE2eGroupControlType.GROUP_LEAVE,
        CspE2eGroupControlType.GROUP_SET_PROFILE_PICTURE,
        CspE2eGroupControlType.GROUP_DELETE_PROFILE_PICTURE,
        CspE2eGroupControlType.GROUP_SYNC_REQUEST,
        CspE2eGroupControlType.GROUP_CALL_START,
    ] as const);
    export function fromNumber(
        value: u53,
        fallback?: CspE2eGroupControlType,
    ): CspE2eGroupControlType {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as CspE2eGroupControlType;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid CspE2eGroupControlType`);
    }
    export function containsNumber(value: u53): value is CspE2eGroupControlType {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is CspE2eGroupControlType {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
    export const NAME_OF = {
        [CspE2eGroupControlType.GROUP_SETUP]: 'GROUP_SETUP',
        [CspE2eGroupControlType.GROUP_NAME]: 'GROUP_NAME',
        [CspE2eGroupControlType.GROUP_LEAVE]: 'GROUP_LEAVE',
        [CspE2eGroupControlType.GROUP_SET_PROFILE_PICTURE]: 'GROUP_SET_PROFILE_PICTURE',
        [CspE2eGroupControlType.GROUP_DELETE_PROFILE_PICTURE]: 'GROUP_DELETE_PROFILE_PICTURE',
        [CspE2eGroupControlType.GROUP_SYNC_REQUEST]: 'GROUP_SYNC_REQUEST',
        [CspE2eGroupControlType.GROUP_CALL_START]: 'GROUP_CALL_START',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace CspE2eForwardSecurityType {
    export const FORWARD_SECURITY_ENVELOPE = 160;
    export type FORWARD_SECURITY_ENVELOPE = typeof FORWARD_SECURITY_ENVELOPE;
}
/**
 * E2EE forward security type.
 *
 * @generate name
 */
export type CspE2eForwardSecurityType =
    (typeof CspE2eForwardSecurityType)[keyof typeof CspE2eForwardSecurityType];
export namespace CspE2eForwardSecurityTypeUtils {
    export const NAME_OF = {
        [CspE2eForwardSecurityType.FORWARD_SECURITY_ENVELOPE]: 'FORWARD_SECURITY_ENVELOPE',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace CspE2eWebSessionResumeType {
    export const WEB_SESSION_RESUME = 254;
    export type WEB_SESSION_RESUME = typeof WEB_SESSION_RESUME;
}
/**
 * E2EE Web session resume type.
 *
 * @generate name
 */
export type CspE2eWebSessionResumeType =
    (typeof CspE2eWebSessionResumeType)[keyof typeof CspE2eWebSessionResumeType];
export namespace CspE2eWebSessionResumeTypeUtils {
    export const NAME_OF = {
        [CspE2eWebSessionResumeType.WEB_SESSION_RESUME]: 'WEB_SESSION_RESUME',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace CspE2eDeliveryReceiptStatus {
    export const RECEIVED = 1;
    export type RECEIVED = typeof RECEIVED;
    export const READ = 2;
    export type READ = typeof READ;
    export const ACKNOWLEDGED = 3;
    export type ACKNOWLEDGED = typeof ACKNOWLEDGED;
    export const DECLINED = 4;
    export type DECLINED = typeof DECLINED;
}
/**
 * E2EE delivery receipt status.
 *
 * @generate convert name
 */
export type CspE2eDeliveryReceiptStatus =
    (typeof CspE2eDeliveryReceiptStatus)[keyof typeof CspE2eDeliveryReceiptStatus];
export namespace CspE2eDeliveryReceiptStatusUtils {
    export const ALL: ReadonlySet<CspE2eDeliveryReceiptStatus> = new Set([
        CspE2eDeliveryReceiptStatus.RECEIVED,
        CspE2eDeliveryReceiptStatus.READ,
        CspE2eDeliveryReceiptStatus.ACKNOWLEDGED,
        CspE2eDeliveryReceiptStatus.DECLINED,
    ] as const);
    export function fromNumber(
        value: u53,
        fallback?: CspE2eDeliveryReceiptStatus,
    ): CspE2eDeliveryReceiptStatus {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as CspE2eDeliveryReceiptStatus;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid CspE2eDeliveryReceiptStatus`);
    }
    export function containsNumber(value: u53): value is CspE2eDeliveryReceiptStatus {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is CspE2eDeliveryReceiptStatus {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
    export const NAME_OF = {
        [CspE2eDeliveryReceiptStatus.RECEIVED]: 'RECEIVED',
        [CspE2eDeliveryReceiptStatus.READ]: 'READ',
        [CspE2eDeliveryReceiptStatus.ACKNOWLEDGED]: 'ACKNOWLEDGED',
        [CspE2eDeliveryReceiptStatus.DECLINED]: 'DECLINED',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace CspE2eMessageUpdateType {
    export const EDIT_MESSAGE = 145;
    export type EDIT_MESSAGE = typeof EDIT_MESSAGE;
    export const DELETE_MESSAGE = 146;
    export type DELETE_MESSAGE = typeof DELETE_MESSAGE;
}
/**
 * E2EE 1:1 Message update (e.g. edit or delete)
 *
 * @generate name convert
 */
export type CspE2eMessageUpdateType =
    (typeof CspE2eMessageUpdateType)[keyof typeof CspE2eMessageUpdateType];
export namespace CspE2eMessageUpdateTypeUtils {
    export const ALL: ReadonlySet<CspE2eMessageUpdateType> = new Set([
        CspE2eMessageUpdateType.EDIT_MESSAGE,
        CspE2eMessageUpdateType.DELETE_MESSAGE,
    ] as const);
    export function fromNumber(
        value: u53,
        fallback?: CspE2eMessageUpdateType,
    ): CspE2eMessageUpdateType {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as CspE2eMessageUpdateType;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid CspE2eMessageUpdateType`);
    }
    export function containsNumber(value: u53): value is CspE2eMessageUpdateType {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is CspE2eMessageUpdateType {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
    export const NAME_OF = {
        [CspE2eMessageUpdateType.EDIT_MESSAGE]: 'EDIT_MESSAGE',
        [CspE2eMessageUpdateType.DELETE_MESSAGE]: 'DELETE_MESSAGE',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace CspE2eGroupMessageUpdateType {
    export const GROUP_EDIT_MESSAGE = 147;
    export type GROUP_EDIT_MESSAGE = typeof GROUP_EDIT_MESSAGE;
    export const GROUP_DELETE_MESSAGE = 148;
    export type GROUP_DELETE_MESSAGE = typeof GROUP_DELETE_MESSAGE;
}
/**
 * E2EE group Message update
 *
 * @generate name convert
 */
export type CspE2eGroupMessageUpdateType =
    (typeof CspE2eGroupMessageUpdateType)[keyof typeof CspE2eGroupMessageUpdateType];
export namespace CspE2eGroupMessageUpdateTypeUtils {
    export const ALL: ReadonlySet<CspE2eGroupMessageUpdateType> = new Set([
        CspE2eGroupMessageUpdateType.GROUP_EDIT_MESSAGE,
        CspE2eGroupMessageUpdateType.GROUP_DELETE_MESSAGE,
    ] as const);
    export function fromNumber(
        value: u53,
        fallback?: CspE2eGroupMessageUpdateType,
    ): CspE2eGroupMessageUpdateType {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as CspE2eGroupMessageUpdateType;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid CspE2eGroupMessageUpdateType`);
    }
    export function containsNumber(value: u53): value is CspE2eGroupMessageUpdateType {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is CspE2eGroupMessageUpdateType {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
    export const NAME_OF = {
        [CspE2eGroupMessageUpdateType.GROUP_EDIT_MESSAGE]: 'GROUP_EDIT_MESSAGE',
        [CspE2eGroupMessageUpdateType.GROUP_DELETE_MESSAGE]: 'GROUP_DELETE_MESSAGE',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace ReceiverType {
    export const CONTACT = 0;
    export type CONTACT = typeof CONTACT;
    export const DISTRIBUTION_LIST = 1;
    export type DISTRIBUTION_LIST = typeof DISTRIBUTION_LIST;
    export const GROUP = 2;
    export type GROUP = typeof GROUP;
}
/**
 * Receiver of an end-to-end encrypted message.
 *
 * @generate convert name
 */
export type ReceiverType = (typeof ReceiverType)[keyof typeof ReceiverType];
export namespace ReceiverTypeUtils {
    export const ALL: ReadonlySet<ReceiverType> = new Set([
        ReceiverType.CONTACT,
        ReceiverType.DISTRIBUTION_LIST,
        ReceiverType.GROUP,
    ] as const);
    export function fromNumber(value: u53, fallback?: ReceiverType): ReceiverType {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as ReceiverType;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid ReceiverType`);
    }
    export function containsNumber(value: u53): value is ReceiverType {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is ReceiverType {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
    export const NAME_OF = {
        [ReceiverType.CONTACT]: 'CONTACT',
        [ReceiverType.DISTRIBUTION_LIST]: 'DISTRIBUTION_LIST',
        [ReceiverType.GROUP]: 'GROUP',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace MessageDirection {
    export const INBOUND = 0;
    export type INBOUND = typeof INBOUND;
    export const OUTBOUND = 1;
    export type OUTBOUND = typeof OUTBOUND;
}
/**
 * Message direction.
 *
 * @generate name
 */
export type MessageDirection = (typeof MessageDirection)[keyof typeof MessageDirection];
export namespace MessageDirectionUtils {
    export const NAME_OF = {
        [MessageDirection.INBOUND]: 'INBOUND',
        [MessageDirection.OUTBOUND]: 'OUTBOUND',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace MessageFilterInstruction {
    export const ACCEPT = 0;
    export type ACCEPT = typeof ACCEPT;
    export const BYPASS_OR_BACKLOG = 1;
    export type BYPASS_OR_BACKLOG = typeof BYPASS_OR_BACKLOG;
    export const REJECT = 2;
    export type REJECT = typeof REJECT;
}
/**
 * Task message filter instruction.
 *
 * @generate name
 */
export type MessageFilterInstruction =
    (typeof MessageFilterInstruction)[keyof typeof MessageFilterInstruction];
export namespace MessageFilterInstructionUtils {
    export const NAME_OF = {
        [MessageFilterInstruction.ACCEPT]: 'ACCEPT',
        [MessageFilterInstruction.BYPASS_OR_BACKLOG]: 'BYPASS_OR_BACKLOG',
        [MessageFilterInstruction.REJECT]: 'REJECT',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace MessageType {
    export const TEXT = 'text';
    export type TEXT = typeof TEXT;
    export const FILE = 'file';
    export type FILE = typeof FILE;
    export const IMAGE = 'image';
    export type IMAGE = typeof IMAGE;
    export const VIDEO = 'video';
    export type VIDEO = typeof VIDEO;
    export const AUDIO = 'audio';
    export type AUDIO = typeof AUDIO;
    export const DELETED = 'deleted';
    export type DELETED = typeof DELETED;
}
/**
 * All possible message types.
 *
 * WARNING: Do not change the internal representation of this enum, since those values are stored
 *          directly in the database!
 *
 * @generate convert
 */
export type MessageType = (typeof MessageType)[keyof typeof MessageType];
export namespace MessageTypeUtils {
    export const ALL: ReadonlySet<MessageType> = new Set([
        MessageType.TEXT,
        MessageType.FILE,
        MessageType.IMAGE,
        MessageType.VIDEO,
        MessageType.AUDIO,
        MessageType.DELETED,
    ] as const);
    export function fromString(value: string, fallback?: MessageType): MessageType {
        if ((ALL as ReadonlySet<string>).has(value)) {
            return value as MessageType;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid MessageType`);
    }
    export function containsString(value: string): value is MessageType {
        return (ALL as ReadonlySet<string>).has(value);
    }
    export function contains(value: unknown): value is MessageType {
        return typeof value === 'string' && (ALL as ReadonlySet<string>).has(value);
    }
}
export namespace StatusMessageType {
    export const GROUP_MEMBER_CHANGED = 'group-member-changed';
    export type GROUP_MEMBER_CHANGED = typeof GROUP_MEMBER_CHANGED;
    export const GROUP_NAME_CHANGED = 'group-name-changed';
    export type GROUP_NAME_CHANGED = typeof GROUP_NAME_CHANGED;
    export const GROUP_CALL_STARTED = 'group-call-started';
    export type GROUP_CALL_STARTED = typeof GROUP_CALL_STARTED;
    export const GROUP_CALL_ENDED = 'group-call-ended';
    export type GROUP_CALL_ENDED = typeof GROUP_CALL_ENDED;
}
/**
 * All possible status message types.
 *
 * WARNING: Do not change the internal representation of this enum, since those values are stored
 *          directly in the database!
 *
 * @generate name convert
 */
export type StatusMessageType = (typeof StatusMessageType)[keyof typeof StatusMessageType];
export namespace StatusMessageTypeUtils {
    export const ALL: ReadonlySet<StatusMessageType> = new Set([
        StatusMessageType.GROUP_MEMBER_CHANGED,
        StatusMessageType.GROUP_NAME_CHANGED,
        StatusMessageType.GROUP_CALL_STARTED,
        StatusMessageType.GROUP_CALL_ENDED,
    ] as const);
    export function fromString(value: string, fallback?: StatusMessageType): StatusMessageType {
        if ((ALL as ReadonlySet<string>).has(value)) {
            return value as StatusMessageType;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid StatusMessageType`);
    }
    export function containsString(value: string): value is StatusMessageType {
        return (ALL as ReadonlySet<string>).has(value);
    }
    export function contains(value: unknown): value is StatusMessageType {
        return typeof value === 'string' && (ALL as ReadonlySet<string>).has(value);
    }
    export const NAME_OF = {
        [StatusMessageType.GROUP_MEMBER_CHANGED]: 'GROUP_MEMBER_CHANGED',
        [StatusMessageType.GROUP_NAME_CHANGED]: 'GROUP_NAME_CHANGED',
        [StatusMessageType.GROUP_CALL_STARTED]: 'GROUP_CALL_STARTED',
        [StatusMessageType.GROUP_CALL_ENDED]: 'GROUP_CALL_ENDED',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace TriggerSource {
    export const SYNC = 0;
    /**
     * An update triggered by synchronisation from another device.
     *
     * This should never trigger further messages to other devices.
     */
    export type SYNC = typeof SYNC;
    export const LOCAL = 1;
    /**
     * An update triggered locally, e.g. by a user interaction.
     *
     * This will always trigger messages to other devices.
     */
    export type LOCAL = typeof LOCAL;
    export const REMOTE = 2;
    /**
     * An update triggered remotely, e.g. by an incoming message.
     *
     * The task that was triggered by the remote message will take care of reflection, but further
     * side effects (e.g. implicit contact creation) will need to be reflected separately.
     */
    export type REMOTE = typeof REMOTE;
}
/**
 * Source that triggered some kind of update.
 */
export type TriggerSource = (typeof TriggerSource)[keyof typeof TriggerSource];
export namespace MessageReaction {
    export const ACKNOWLEDGE = 0;
    export type ACKNOWLEDGE = typeof ACKNOWLEDGE;
    export const DECLINE = 1;
    export type DECLINE = typeof DECLINE;
}
/**
 * Message reaction.
 *
 * WARNING: Do not change the internal representation of this enum,
 *          since those values are stored directly in the database!
 *
 * @generate convert name
 */
export type MessageReaction = (typeof MessageReaction)[keyof typeof MessageReaction];
export namespace MessageReactionUtils {
    export const ALL: ReadonlySet<MessageReaction> = new Set([
        MessageReaction.ACKNOWLEDGE,
        MessageReaction.DECLINE,
    ] as const);
    export function fromNumber(value: u53, fallback?: MessageReaction): MessageReaction {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as MessageReaction;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid MessageReaction`);
    }
    export function containsNumber(value: u53): value is MessageReaction {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is MessageReaction {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
    export const NAME_OF = {
        [MessageReaction.ACKNOWLEDGE]: 'ACKNOWLEDGE',
        [MessageReaction.DECLINE]: 'DECLINE',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace MessageQueryDirection {
    export const OLDER = 0;
    export type OLDER = typeof OLDER;
    export const NEWER = 1;
    export type NEWER = typeof NEWER;
}
/**
 * Message fetch direction (either older or newer messages).
 */
export type MessageQueryDirection =
    (typeof MessageQueryDirection)[keyof typeof MessageQueryDirection];
export namespace GlobalPropertyKey {
    export const LAST_MEDIATOR_CONNECTION = 'lastMediatorConnection';
    /** Connection Metadata of the last successfull mediator connection */
    export type LAST_MEDIATOR_CONNECTION = typeof LAST_MEDIATOR_CONNECTION;
    export const APPLICATION_STATE = 'applicationState';
    /** Application state information */
    export type APPLICATION_STATE = typeof APPLICATION_STATE;
}
/**
 * Global Property Keys of this client. Used as key for the globalProperties table.
 *
 * @generate convert name
 */
export type GlobalPropertyKey = (typeof GlobalPropertyKey)[keyof typeof GlobalPropertyKey];
export namespace GlobalPropertyKeyUtils {
    export const ALL: ReadonlySet<GlobalPropertyKey> = new Set([
        GlobalPropertyKey.LAST_MEDIATOR_CONNECTION,
        GlobalPropertyKey.APPLICATION_STATE,
    ] as const);
    export function fromString(value: string, fallback?: GlobalPropertyKey): GlobalPropertyKey {
        if ((ALL as ReadonlySet<string>).has(value)) {
            return value as GlobalPropertyKey;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid GlobalPropertyKey`);
    }
    export function containsString(value: string): value is GlobalPropertyKey {
        return (ALL as ReadonlySet<string>).has(value);
    }
    export function contains(value: unknown): value is GlobalPropertyKey {
        return typeof value === 'string' && (ALL as ReadonlySet<string>).has(value);
    }
    export const NAME_OF = {
        [GlobalPropertyKey.LAST_MEDIATOR_CONNECTION]: 'LAST_MEDIATOR_CONNECTION',
        [GlobalPropertyKey.APPLICATION_STATE]: 'APPLICATION_STATE',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace D2dCspMessageType {
    export const INVALID = 0;
    export type INVALID = typeof INVALID;
    export const TEXT = 1;
    export type TEXT = typeof TEXT;
    export const DEPRECATED_IMAGE = 2;
    export type DEPRECATED_IMAGE = typeof DEPRECATED_IMAGE;
    export const LOCATION = 16;
    export type LOCATION = typeof LOCATION;
    export const DEPRECATED_AUDIO = 20;
    export type DEPRECATED_AUDIO = typeof DEPRECATED_AUDIO;
    export const DEPRECATED_VIDEO = 19;
    export type DEPRECATED_VIDEO = typeof DEPRECATED_VIDEO;
    export const FILE = 23;
    export type FILE = typeof FILE;
    export const POLL_SETUP = 21;
    export type POLL_SETUP = typeof POLL_SETUP;
    export const POLL_VOTE = 22;
    export type POLL_VOTE = typeof POLL_VOTE;
    export const CALL_OFFER = 96;
    export type CALL_OFFER = typeof CALL_OFFER;
    export const CALL_ANSWER = 97;
    export type CALL_ANSWER = typeof CALL_ANSWER;
    export const CALL_ICE_CANDIDATE = 98;
    export type CALL_ICE_CANDIDATE = typeof CALL_ICE_CANDIDATE;
    export const CALL_HANGUP = 99;
    export type CALL_HANGUP = typeof CALL_HANGUP;
    export const CALL_RINGING = 100;
    export type CALL_RINGING = typeof CALL_RINGING;
    export const DELIVERY_RECEIPT = 128;
    export type DELIVERY_RECEIPT = typeof DELIVERY_RECEIPT;
    export const TYPING_INDICATOR = 144;
    export type TYPING_INDICATOR = typeof TYPING_INDICATOR;
    export const CONTACT_SET_PROFILE_PICTURE = 24;
    export type CONTACT_SET_PROFILE_PICTURE = typeof CONTACT_SET_PROFILE_PICTURE;
    export const CONTACT_DELETE_PROFILE_PICTURE = 25;
    export type CONTACT_DELETE_PROFILE_PICTURE = typeof CONTACT_DELETE_PROFILE_PICTURE;
    export const CONTACT_REQUEST_PROFILE_PICTURE = 26;
    export type CONTACT_REQUEST_PROFILE_PICTURE = typeof CONTACT_REQUEST_PROFILE_PICTURE;
    export const GROUP_SETUP = 74;
    export type GROUP_SETUP = typeof GROUP_SETUP;
    export const GROUP_NAME = 75;
    export type GROUP_NAME = typeof GROUP_NAME;
    export const GROUP_LEAVE = 76;
    export type GROUP_LEAVE = typeof GROUP_LEAVE;
    export const GROUP_SET_PROFILE_PICTURE = 80;
    export type GROUP_SET_PROFILE_PICTURE = typeof GROUP_SET_PROFILE_PICTURE;
    export const GROUP_DELETE_PROFILE_PICTURE = 84;
    export type GROUP_DELETE_PROFILE_PICTURE = typeof GROUP_DELETE_PROFILE_PICTURE;
    export const GROUP_SYNC_REQUEST = 81;
    export type GROUP_SYNC_REQUEST = typeof GROUP_SYNC_REQUEST;
    export const GROUP_CALL_START = 79;
    export type GROUP_CALL_START = typeof GROUP_CALL_START;
    export const GROUP_TEXT = 65;
    export type GROUP_TEXT = typeof GROUP_TEXT;
    export const GROUP_LOCATION = 66;
    export type GROUP_LOCATION = typeof GROUP_LOCATION;
    export const GROUP_IMAGE = 67;
    export type GROUP_IMAGE = typeof GROUP_IMAGE;
    export const GROUP_AUDIO = 69;
    export type GROUP_AUDIO = typeof GROUP_AUDIO;
    export const GROUP_VIDEO = 68;
    export type GROUP_VIDEO = typeof GROUP_VIDEO;
    export const GROUP_FILE = 70;
    export type GROUP_FILE = typeof GROUP_FILE;
    export const GROUP_POLL_SETUP = 82;
    export type GROUP_POLL_SETUP = typeof GROUP_POLL_SETUP;
    export const GROUP_POLL_VOTE = 83;
    export type GROUP_POLL_VOTE = typeof GROUP_POLL_VOTE;
    export const GROUP_DELIVERY_RECEIPT = 129;
    export type GROUP_DELIVERY_RECEIPT = typeof GROUP_DELIVERY_RECEIPT;
    export const WEB_SESSION_RESUME = 254;
    export type WEB_SESSION_RESUME = typeof WEB_SESSION_RESUME;
    export const EDIT_MESSAGE = 145;
    export type EDIT_MESSAGE = typeof EDIT_MESSAGE;
    export const DELETE_MESSAGE = 146;
    export type DELETE_MESSAGE = typeof DELETE_MESSAGE;
    export const GROUP_EDIT_MESSAGE = 147;
    export type GROUP_EDIT_MESSAGE = typeof GROUP_EDIT_MESSAGE;
    export const GROUP_DELETE_MESSAGE = 148;
    export type GROUP_DELETE_MESSAGE = typeof GROUP_DELETE_MESSAGE;
}
/**
 * PROTOBUF
 * ========
 *
 * WARNING: Do not change the internal representation of these enums since those values are used
 *          directly by the protocol **and** are stored directly in the database!
 *
 * TODO(DESK-48): These enums are pulled from protobuf-generated files. We should generate them directly!
 */
/** @generate convert */
export type D2dCspMessageType = (typeof D2dCspMessageType)[keyof typeof D2dCspMessageType];
export namespace D2dCspMessageTypeUtils {
    export const ALL: ReadonlySet<D2dCspMessageType> = new Set([
        D2dCspMessageType.INVALID,
        D2dCspMessageType.TEXT,
        D2dCspMessageType.DEPRECATED_IMAGE,
        D2dCspMessageType.LOCATION,
        D2dCspMessageType.DEPRECATED_AUDIO,
        D2dCspMessageType.DEPRECATED_VIDEO,
        D2dCspMessageType.FILE,
        D2dCspMessageType.POLL_SETUP,
        D2dCspMessageType.POLL_VOTE,
        D2dCspMessageType.CALL_OFFER,
        D2dCspMessageType.CALL_ANSWER,
        D2dCspMessageType.CALL_ICE_CANDIDATE,
        D2dCspMessageType.CALL_HANGUP,
        D2dCspMessageType.CALL_RINGING,
        D2dCspMessageType.DELIVERY_RECEIPT,
        D2dCspMessageType.TYPING_INDICATOR,
        D2dCspMessageType.CONTACT_SET_PROFILE_PICTURE,
        D2dCspMessageType.CONTACT_DELETE_PROFILE_PICTURE,
        D2dCspMessageType.CONTACT_REQUEST_PROFILE_PICTURE,
        D2dCspMessageType.GROUP_SETUP,
        D2dCspMessageType.GROUP_NAME,
        D2dCspMessageType.GROUP_LEAVE,
        D2dCspMessageType.GROUP_SET_PROFILE_PICTURE,
        D2dCspMessageType.GROUP_DELETE_PROFILE_PICTURE,
        D2dCspMessageType.GROUP_SYNC_REQUEST,
        D2dCspMessageType.GROUP_CALL_START,
        D2dCspMessageType.GROUP_TEXT,
        D2dCspMessageType.GROUP_LOCATION,
        D2dCspMessageType.GROUP_IMAGE,
        D2dCspMessageType.GROUP_AUDIO,
        D2dCspMessageType.GROUP_VIDEO,
        D2dCspMessageType.GROUP_FILE,
        D2dCspMessageType.GROUP_POLL_SETUP,
        D2dCspMessageType.GROUP_POLL_VOTE,
        D2dCspMessageType.GROUP_DELIVERY_RECEIPT,
        D2dCspMessageType.WEB_SESSION_RESUME,
        D2dCspMessageType.EDIT_MESSAGE,
        D2dCspMessageType.DELETE_MESSAGE,
        D2dCspMessageType.GROUP_EDIT_MESSAGE,
        D2dCspMessageType.GROUP_DELETE_MESSAGE,
    ] as const);
    export function fromNumber(value: u53, fallback?: D2dCspMessageType): D2dCspMessageType {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as D2dCspMessageType;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid D2dCspMessageType`);
    }
    export function containsNumber(value: u53): value is D2dCspMessageType {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is D2dCspMessageType {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace AcquaintanceLevel {
    export const DIRECT = 0;
    /**
     * The contact was explicitly added by the user or a 1:1 conversation with
     * the contact has been initiated.
     */
    export type DIRECT = typeof DIRECT;
    export const GROUP = 1;
    /**
     * The contact is part of a group the user is also part of. The contact was
     * not explicitly added and no 1:1 conversation has been initiated.
     */
    export type GROUP = typeof GROUP;
}
/** @generate convert */
export type AcquaintanceLevel = (typeof AcquaintanceLevel)[keyof typeof AcquaintanceLevel];
export namespace AcquaintanceLevelUtils {
    export const ALL: ReadonlySet<AcquaintanceLevel> = new Set([
        AcquaintanceLevel.DIRECT,
        AcquaintanceLevel.GROUP,
    ] as const);
    export function fromNumber(value: u53, fallback?: AcquaintanceLevel): AcquaintanceLevel {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as AcquaintanceLevel;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid AcquaintanceLevel`);
    }
    export function containsNumber(value: u53): value is AcquaintanceLevel {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is AcquaintanceLevel {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace ActivityState {
    export const ACTIVE = 0;
    export type ACTIVE = typeof ACTIVE;
    export const INACTIVE = 1;
    export type INACTIVE = typeof INACTIVE;
    export const INVALID = 2;
    export type INVALID = typeof INVALID;
}
/** @generate convert */
export type ActivityState = (typeof ActivityState)[keyof typeof ActivityState];
export namespace ActivityStateUtils {
    export const ALL: ReadonlySet<ActivityState> = new Set([
        ActivityState.ACTIVE,
        ActivityState.INACTIVE,
        ActivityState.INVALID,
    ] as const);
    export function fromNumber(value: u53, fallback?: ActivityState): ActivityState {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as ActivityState;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid ActivityState`);
    }
    export function containsNumber(value: u53): value is ActivityState {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is ActivityState {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace ContactNotificationTriggerPolicy {
    export const NEVER = 0;
    export type NEVER = typeof NEVER;
}
/** @generate convert */
export type ContactNotificationTriggerPolicy =
    (typeof ContactNotificationTriggerPolicy)[keyof typeof ContactNotificationTriggerPolicy];
export namespace ContactNotificationTriggerPolicyUtils {
    export const ALL: ReadonlySet<ContactNotificationTriggerPolicy> = new Set([
        ContactNotificationTriggerPolicy.NEVER,
    ] as const);
    export function fromNumber(
        value: u53,
        fallback?: ContactNotificationTriggerPolicy,
    ): ContactNotificationTriggerPolicy {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as ContactNotificationTriggerPolicy;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid ContactNotificationTriggerPolicy`);
    }
    export function containsNumber(value: u53): value is ContactNotificationTriggerPolicy {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is ContactNotificationTriggerPolicy {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace ConversationCategory {
    export const DEFAULT = 0;
    export type DEFAULT = typeof DEFAULT;
    export const PROTECTED = 1;
    export type PROTECTED = typeof PROTECTED;
}
/** @generate convert */
export type ConversationCategory = (typeof ConversationCategory)[keyof typeof ConversationCategory];
export namespace ConversationCategoryUtils {
    export const ALL: ReadonlySet<ConversationCategory> = new Set([
        ConversationCategory.DEFAULT,
        ConversationCategory.PROTECTED,
    ] as const);
    export function fromNumber(value: u53, fallback?: ConversationCategory): ConversationCategory {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as ConversationCategory;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid ConversationCategory`);
    }
    export function containsNumber(value: u53): value is ConversationCategory {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is ConversationCategory {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace ConversationVisibility {
    export const SHOW = 0;
    export type SHOW = typeof SHOW;
    export const ARCHIVED = 1;
    export type ARCHIVED = typeof ARCHIVED;
    export const PINNED = 2;
    export type PINNED = typeof PINNED;
}
/** @generate convert */
export type ConversationVisibility =
    (typeof ConversationVisibility)[keyof typeof ConversationVisibility];
export namespace ConversationVisibilityUtils {
    export const ALL: ReadonlySet<ConversationVisibility> = new Set([
        ConversationVisibility.SHOW,
        ConversationVisibility.ARCHIVED,
        ConversationVisibility.PINNED,
    ] as const);
    export function fromNumber(
        value: u53,
        fallback?: ConversationVisibility,
    ): ConversationVisibility {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as ConversationVisibility;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid ConversationVisibility`);
    }
    export function containsNumber(value: u53): value is ConversationVisibility {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is ConversationVisibility {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace GroupNotificationTriggerPolicy {
    export const MENTIONED = 0;
    export type MENTIONED = typeof MENTIONED;
    export const NEVER = 1;
    export type NEVER = typeof NEVER;
}
/** @generate convert */
export type GroupNotificationTriggerPolicy =
    (typeof GroupNotificationTriggerPolicy)[keyof typeof GroupNotificationTriggerPolicy];
export namespace GroupNotificationTriggerPolicyUtils {
    export const ALL: ReadonlySet<GroupNotificationTriggerPolicy> = new Set([
        GroupNotificationTriggerPolicy.MENTIONED,
        GroupNotificationTriggerPolicy.NEVER,
    ] as const);
    export function fromNumber(
        value: u53,
        fallback?: GroupNotificationTriggerPolicy,
    ): GroupNotificationTriggerPolicy {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as GroupNotificationTriggerPolicy;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid GroupNotificationTriggerPolicy`);
    }
    export function containsNumber(value: u53): value is GroupNotificationTriggerPolicy {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is GroupNotificationTriggerPolicy {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace IdentityType {
    export const REGULAR = 0;
    export type REGULAR = typeof REGULAR;
    export const WORK = 1;
    export type WORK = typeof WORK;
}
/** @generate convert */
export type IdentityType = (typeof IdentityType)[keyof typeof IdentityType];
export namespace IdentityTypeUtils {
    export const ALL: ReadonlySet<IdentityType> = new Set([
        IdentityType.REGULAR,
        IdentityType.WORK,
    ] as const);
    export function fromNumber(value: u53, fallback?: IdentityType): IdentityType {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as IdentityType;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid IdentityType`);
    }
    export function containsNumber(value: u53): value is IdentityType {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is IdentityType {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace NotificationSoundPolicy {
    export const MUTED = 0;
    export type MUTED = typeof MUTED;
}
/** @generate convert */
export type NotificationSoundPolicy =
    (typeof NotificationSoundPolicy)[keyof typeof NotificationSoundPolicy];
export namespace NotificationSoundPolicyUtils {
    export const ALL: ReadonlySet<NotificationSoundPolicy> = new Set([
        NotificationSoundPolicy.MUTED,
    ] as const);
    export function fromNumber(
        value: u53,
        fallback?: NotificationSoundPolicy,
    ): NotificationSoundPolicy {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as NotificationSoundPolicy;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid NotificationSoundPolicy`);
    }
    export function containsNumber(value: u53): value is NotificationSoundPolicy {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is NotificationSoundPolicy {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace ReadReceiptPolicy {
    export const SEND_READ_RECEIPT = 0;
    export type SEND_READ_RECEIPT = typeof SEND_READ_RECEIPT;
    export const DONT_SEND_READ_RECEIPT = 1;
    export type DONT_SEND_READ_RECEIPT = typeof DONT_SEND_READ_RECEIPT;
}
/** @generate convert */
export type ReadReceiptPolicy = (typeof ReadReceiptPolicy)[keyof typeof ReadReceiptPolicy];
export namespace ReadReceiptPolicyUtils {
    export const ALL: ReadonlySet<ReadReceiptPolicy> = new Set([
        ReadReceiptPolicy.SEND_READ_RECEIPT,
        ReadReceiptPolicy.DONT_SEND_READ_RECEIPT,
    ] as const);
    export function fromNumber(value: u53, fallback?: ReadReceiptPolicy): ReadReceiptPolicy {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as ReadReceiptPolicy;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid ReadReceiptPolicy`);
    }
    export function containsNumber(value: u53): value is ReadReceiptPolicy {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is ReadReceiptPolicy {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace SyncState {
    export const INITIAL = 0;
    export type INITIAL = typeof INITIAL;
    export const IMPORTED = 1;
    export type IMPORTED = typeof IMPORTED;
    export const CUSTOM = 2;
    export type CUSTOM = typeof CUSTOM;
}
/** @generate convert */
export type SyncState = (typeof SyncState)[keyof typeof SyncState];
export namespace SyncStateUtils {
    export const ALL: ReadonlySet<SyncState> = new Set([
        SyncState.INITIAL,
        SyncState.IMPORTED,
        SyncState.CUSTOM,
    ] as const);
    export function fromNumber(value: u53, fallback?: SyncState): SyncState {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as SyncState;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid SyncState`);
    }
    export function containsNumber(value: u53): value is SyncState {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is SyncState {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace TransactionScope {
    export const USER_PROFILE_SYNC = 0;
    export type USER_PROFILE_SYNC = typeof USER_PROFILE_SYNC;
    export const CONTACT_SYNC = 1;
    export type CONTACT_SYNC = typeof CONTACT_SYNC;
    export const GROUP_SYNC = 2;
    export type GROUP_SYNC = typeof GROUP_SYNC;
    export const DISTRIBUTION_LIST_SYNC = 3;
    export type DISTRIBUTION_LIST_SYNC = typeof DISTRIBUTION_LIST_SYNC;
    export const SETTINGS_SYNC = 4;
    export type SETTINGS_SYNC = typeof SETTINGS_SYNC;
    export const NEW_DEVICE_SYNC = 5;
    export type NEW_DEVICE_SYNC = typeof NEW_DEVICE_SYNC;
}
/** @generate convert name */
export type TransactionScope = (typeof TransactionScope)[keyof typeof TransactionScope];
export namespace TransactionScopeUtils {
    export const ALL: ReadonlySet<TransactionScope> = new Set([
        TransactionScope.USER_PROFILE_SYNC,
        TransactionScope.CONTACT_SYNC,
        TransactionScope.GROUP_SYNC,
        TransactionScope.DISTRIBUTION_LIST_SYNC,
        TransactionScope.SETTINGS_SYNC,
        TransactionScope.NEW_DEVICE_SYNC,
    ] as const);
    export function fromNumber(value: u53, fallback?: TransactionScope): TransactionScope {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as TransactionScope;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid TransactionScope`);
    }
    export function containsNumber(value: u53): value is TransactionScope {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is TransactionScope {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
    export const NAME_OF = {
        [TransactionScope.USER_PROFILE_SYNC]: 'USER_PROFILE_SYNC',
        [TransactionScope.CONTACT_SYNC]: 'CONTACT_SYNC',
        [TransactionScope.GROUP_SYNC]: 'GROUP_SYNC',
        [TransactionScope.DISTRIBUTION_LIST_SYNC]: 'DISTRIBUTION_LIST_SYNC',
        [TransactionScope.SETTINGS_SYNC]: 'SETTINGS_SYNC',
        [TransactionScope.NEW_DEVICE_SYNC]: 'NEW_DEVICE_SYNC',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace TypingIndicatorPolicy {
    export const SEND_TYPING_INDICATOR = 0;
    export type SEND_TYPING_INDICATOR = typeof SEND_TYPING_INDICATOR;
    export const DONT_SEND_TYPING_INDICATOR = 1;
    export type DONT_SEND_TYPING_INDICATOR = typeof DONT_SEND_TYPING_INDICATOR;
}
/** @generate convert */
export type TypingIndicatorPolicy =
    (typeof TypingIndicatorPolicy)[keyof typeof TypingIndicatorPolicy];
export namespace TypingIndicatorPolicyUtils {
    export const ALL: ReadonlySet<TypingIndicatorPolicy> = new Set([
        TypingIndicatorPolicy.SEND_TYPING_INDICATOR,
        TypingIndicatorPolicy.DONT_SEND_TYPING_INDICATOR,
    ] as const);
    export function fromNumber(
        value: u53,
        fallback?: TypingIndicatorPolicy,
    ): TypingIndicatorPolicy {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as TypingIndicatorPolicy;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid TypingIndicatorPolicy`);
    }
    export function containsNumber(value: u53): value is TypingIndicatorPolicy {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is TypingIndicatorPolicy {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace VerificationLevel {
    export const UNVERIFIED = 0;
    export type UNVERIFIED = typeof UNVERIFIED;
    export const SERVER_VERIFIED = 1;
    export type SERVER_VERIFIED = typeof SERVER_VERIFIED;
    export const FULLY_VERIFIED = 2;
    export type FULLY_VERIFIED = typeof FULLY_VERIFIED;
}
/** @generate convert */
export type VerificationLevel = (typeof VerificationLevel)[keyof typeof VerificationLevel];
export namespace VerificationLevelUtils {
    export const ALL: ReadonlySet<VerificationLevel> = new Set([
        VerificationLevel.UNVERIFIED,
        VerificationLevel.SERVER_VERIFIED,
        VerificationLevel.FULLY_VERIFIED,
    ] as const);
    export function fromNumber(value: u53, fallback?: VerificationLevel): VerificationLevel {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as VerificationLevel;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid VerificationLevel`);
    }
    export function containsNumber(value: u53): value is VerificationLevel {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is VerificationLevel {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace WorkVerificationLevel {
    export const NONE = 0;
    export type NONE = typeof NONE;
    export const WORK_SUBSCRIPTION_VERIFIED = 1;
    export type WORK_SUBSCRIPTION_VERIFIED = typeof WORK_SUBSCRIPTION_VERIFIED;
}
/** @generate convert */
export type WorkVerificationLevel =
    (typeof WorkVerificationLevel)[keyof typeof WorkVerificationLevel];
export namespace WorkVerificationLevelUtils {
    export const ALL: ReadonlySet<WorkVerificationLevel> = new Set([
        WorkVerificationLevel.NONE,
        WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED,
    ] as const);
    export function fromNumber(
        value: u53,
        fallback?: WorkVerificationLevel,
    ): WorkVerificationLevel {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as WorkVerificationLevel;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid WorkVerificationLevel`);
    }
    export function containsNumber(value: u53): value is WorkVerificationLevel {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is WorkVerificationLevel {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace DeviceSlotState {
    export const NEW = 0;
    export type NEW = typeof NEW;
    export const EXISTING = 1;
    export type EXISTING = typeof EXISTING;
}
/** @generate convert */
export type DeviceSlotState = (typeof DeviceSlotState)[keyof typeof DeviceSlotState];
export namespace DeviceSlotStateUtils {
    export const ALL: ReadonlySet<DeviceSlotState> = new Set([
        DeviceSlotState.NEW,
        DeviceSlotState.EXISTING,
    ] as const);
    export function fromNumber(value: u53, fallback?: DeviceSlotState): DeviceSlotState {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as DeviceSlotState;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid DeviceSlotState`);
    }
    export function containsNumber(value: u53): value is DeviceSlotState {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is DeviceSlotState {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace GroupUserState {
    export const MEMBER = 0;
    /** The user is a member (or creator) of the group. */
    export type MEMBER = typeof MEMBER;
    export const KICKED = 1;
    /** The user has been kicked from the group. Implies that the group has been marked as _left_. */
    export type KICKED = typeof KICKED;
    export const LEFT = 2;
    /** The user left the group. Implies that the group has been marked as _left_. */
    export type LEFT = typeof LEFT;
}
/** @generate convert name */
export type GroupUserState = (typeof GroupUserState)[keyof typeof GroupUserState];
export namespace GroupUserStateUtils {
    export const ALL: ReadonlySet<GroupUserState> = new Set([
        GroupUserState.MEMBER,
        GroupUserState.KICKED,
        GroupUserState.LEFT,
    ] as const);
    export function fromNumber(value: u53, fallback?: GroupUserState): GroupUserState {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as GroupUserState;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid GroupUserState`);
    }
    export function containsNumber(value: u53): value is GroupUserState {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is GroupUserState {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
    export const NAME_OF = {
        [GroupUserState.MEMBER]: 'MEMBER',
        [GroupUserState.KICKED]: 'KICKED',
        [GroupUserState.LEFT]: 'LEFT',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace ContactSyncPolicy {
    export const NOT_SYNCED = 0;
    export type NOT_SYNCED = typeof NOT_SYNCED;
    export const SYNC = 1;
    export type SYNC = typeof SYNC;
}
/** @generate convert */
export type ContactSyncPolicy = (typeof ContactSyncPolicy)[keyof typeof ContactSyncPolicy];
export namespace ContactSyncPolicyUtils {
    export const ALL: ReadonlySet<ContactSyncPolicy> = new Set([
        ContactSyncPolicy.NOT_SYNCED,
        ContactSyncPolicy.SYNC,
    ] as const);
    export function fromNumber(value: u53, fallback?: ContactSyncPolicy): ContactSyncPolicy {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as ContactSyncPolicy;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid ContactSyncPolicy`);
    }
    export function containsNumber(value: u53): value is ContactSyncPolicy {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is ContactSyncPolicy {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace UnknownContactPolicy {
    export const ALLOW_UNKNOWN = 0;
    export type ALLOW_UNKNOWN = typeof ALLOW_UNKNOWN;
    export const BLOCK_UNKNOWN = 1;
    export type BLOCK_UNKNOWN = typeof BLOCK_UNKNOWN;
}
/** @generate convert */
export type UnknownContactPolicy = (typeof UnknownContactPolicy)[keyof typeof UnknownContactPolicy];
export namespace UnknownContactPolicyUtils {
    export const ALL: ReadonlySet<UnknownContactPolicy> = new Set([
        UnknownContactPolicy.ALLOW_UNKNOWN,
        UnknownContactPolicy.BLOCK_UNKNOWN,
    ] as const);
    export function fromNumber(value: u53, fallback?: UnknownContactPolicy): UnknownContactPolicy {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as UnknownContactPolicy;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid UnknownContactPolicy`);
    }
    export function containsNumber(value: u53): value is UnknownContactPolicy {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is UnknownContactPolicy {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace O2oCallPolicy {
    export const ALLOW_CALL = 0;
    export type ALLOW_CALL = typeof ALLOW_CALL;
    export const DENY_CALL = 1;
    export type DENY_CALL = typeof DENY_CALL;
}
/** @generate convert */
export type O2oCallPolicy = (typeof O2oCallPolicy)[keyof typeof O2oCallPolicy];
export namespace O2oCallPolicyUtils {
    export const ALL: ReadonlySet<O2oCallPolicy> = new Set([
        O2oCallPolicy.ALLOW_CALL,
        O2oCallPolicy.DENY_CALL,
    ] as const);
    export function fromNumber(value: u53, fallback?: O2oCallPolicy): O2oCallPolicy {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as O2oCallPolicy;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid O2oCallPolicy`);
    }
    export function containsNumber(value: u53): value is O2oCallPolicy {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is O2oCallPolicy {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace O2oCallConnectionPolicy {
    export const ALLOW_DIRECT = 0;
    export type ALLOW_DIRECT = typeof ALLOW_DIRECT;
    export const REQUIRE_RELAY = 1;
    export type REQUIRE_RELAY = typeof REQUIRE_RELAY;
}
/** @generate convert */
export type O2oCallConnectionPolicy =
    (typeof O2oCallConnectionPolicy)[keyof typeof O2oCallConnectionPolicy];
export namespace O2oCallConnectionPolicyUtils {
    export const ALL: ReadonlySet<O2oCallConnectionPolicy> = new Set([
        O2oCallConnectionPolicy.ALLOW_DIRECT,
        O2oCallConnectionPolicy.REQUIRE_RELAY,
    ] as const);
    export function fromNumber(
        value: u53,
        fallback?: O2oCallConnectionPolicy,
    ): O2oCallConnectionPolicy {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as O2oCallConnectionPolicy;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid O2oCallConnectionPolicy`);
    }
    export function containsNumber(value: u53): value is O2oCallConnectionPolicy {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is O2oCallConnectionPolicy {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace O2oCallVideoPolicy {
    export const ALLOW_VIDEO = 0;
    export type ALLOW_VIDEO = typeof ALLOW_VIDEO;
    export const DENY_VIDEO = 1;
    export type DENY_VIDEO = typeof DENY_VIDEO;
}
/** @generate convert */
export type O2oCallVideoPolicy = (typeof O2oCallVideoPolicy)[keyof typeof O2oCallVideoPolicy];
export namespace O2oCallVideoPolicyUtils {
    export const ALL: ReadonlySet<O2oCallVideoPolicy> = new Set([
        O2oCallVideoPolicy.ALLOW_VIDEO,
        O2oCallVideoPolicy.DENY_VIDEO,
    ] as const);
    export function fromNumber(value: u53, fallback?: O2oCallVideoPolicy): O2oCallVideoPolicy {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as O2oCallVideoPolicy;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid O2oCallVideoPolicy`);
    }
    export function containsNumber(value: u53): value is O2oCallVideoPolicy {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is O2oCallVideoPolicy {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace GroupCallPolicy {
    export const ALLOW_GROUP_CALL = 0;
    export type ALLOW_GROUP_CALL = typeof ALLOW_GROUP_CALL;
    export const DENY_GROUP_CALL = 1;
    export type DENY_GROUP_CALL = typeof DENY_GROUP_CALL;
}
/** @generate convert */
export type GroupCallPolicy = (typeof GroupCallPolicy)[keyof typeof GroupCallPolicy];
export namespace GroupCallPolicyUtils {
    export const ALL: ReadonlySet<GroupCallPolicy> = new Set([
        GroupCallPolicy.ALLOW_GROUP_CALL,
        GroupCallPolicy.DENY_GROUP_CALL,
    ] as const);
    export function fromNumber(value: u53, fallback?: GroupCallPolicy): GroupCallPolicy {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as GroupCallPolicy;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid GroupCallPolicy`);
    }
    export function containsNumber(value: u53): value is GroupCallPolicy {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is GroupCallPolicy {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace ScreenshotPolicy {
    export const ALLOW_SCREENSHOT = 0;
    export type ALLOW_SCREENSHOT = typeof ALLOW_SCREENSHOT;
    export const DENY_SCREENSHOT = 1;
    export type DENY_SCREENSHOT = typeof DENY_SCREENSHOT;
}
/** @generate convert */
export type ScreenshotPolicy = (typeof ScreenshotPolicy)[keyof typeof ScreenshotPolicy];
export namespace ScreenshotPolicyUtils {
    export const ALL: ReadonlySet<ScreenshotPolicy> = new Set([
        ScreenshotPolicy.ALLOW_SCREENSHOT,
        ScreenshotPolicy.DENY_SCREENSHOT,
    ] as const);
    export function fromNumber(value: u53, fallback?: ScreenshotPolicy): ScreenshotPolicy {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as ScreenshotPolicy;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid ScreenshotPolicy`);
    }
    export function containsNumber(value: u53): value is ScreenshotPolicy {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is ScreenshotPolicy {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace KeyboardDataCollectionPolicy {
    export const ALLOW_DATA_COLLECTION = 0;
    export type ALLOW_DATA_COLLECTION = typeof ALLOW_DATA_COLLECTION;
    export const DENY_DATA_COLLECTION = 1;
    export type DENY_DATA_COLLECTION = typeof DENY_DATA_COLLECTION;
}
/** @generate convert */
export type KeyboardDataCollectionPolicy =
    (typeof KeyboardDataCollectionPolicy)[keyof typeof KeyboardDataCollectionPolicy];
export namespace KeyboardDataCollectionPolicyUtils {
    export const ALL: ReadonlySet<KeyboardDataCollectionPolicy> = new Set([
        KeyboardDataCollectionPolicy.ALLOW_DATA_COLLECTION,
        KeyboardDataCollectionPolicy.DENY_DATA_COLLECTION,
    ] as const);
    export function fromNumber(
        value: u53,
        fallback?: KeyboardDataCollectionPolicy,
    ): KeyboardDataCollectionPolicy {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as KeyboardDataCollectionPolicy;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid KeyboardDataCollectionPolicy`);
    }
    export function containsNumber(value: u53): value is KeyboardDataCollectionPolicy {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is KeyboardDataCollectionPolicy {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace TimeFormat {
    export const TIME_24H = 0;
    export type TIME_24H = typeof TIME_24H;
    export const TIME_12H = 1;
    export type TIME_12H = typeof TIME_12H;
}
/** @generate convert */
export type TimeFormat = (typeof TimeFormat)[keyof typeof TimeFormat];
export namespace TimeFormatUtils {
    export const ALL: ReadonlySet<TimeFormat> = new Set([
        TimeFormat.TIME_24H,
        TimeFormat.TIME_12H,
    ] as const);
    export function fromNumber(value: u53, fallback?: TimeFormat): TimeFormat {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as TimeFormat;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid TimeFormat`);
    }
    export function containsNumber(value: u53): value is TimeFormat {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is TimeFormat {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace InactiveContactsPolicy {
    export const SHOW = 0;
    export type SHOW = typeof SHOW;
    export const HIDE = 1;
    export type HIDE = typeof HIDE;
}
/** @generate convert **/
export type InactiveContactsPolicy =
    (typeof InactiveContactsPolicy)[keyof typeof InactiveContactsPolicy];
export namespace InactiveContactsPolicyUtils {
    export const ALL: ReadonlySet<InactiveContactsPolicy> = new Set([
        InactiveContactsPolicy.SHOW,
        InactiveContactsPolicy.HIDE,
    ] as const);
    export function fromNumber(
        value: u53,
        fallback?: InactiveContactsPolicy,
    ): InactiveContactsPolicy {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as InactiveContactsPolicy;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid InactiveContactsPolicy`);
    }
    export function containsNumber(value: u53): value is InactiveContactsPolicy {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is InactiveContactsPolicy {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace ElectronIpcCommand {
    export const ERROR = 'error';
    export type ERROR = typeof ERROR;
    export const GET_APP_PATH = 'getAppApath';
    export type GET_APP_PATH = typeof GET_APP_PATH;
    export const GET_SYSTEM_INFO = 'getSystemInfo';
    export type GET_SYSTEM_INFO = typeof GET_SYSTEM_INFO;
    export const LOG_TO_FILE = 'logToFile';
    export type LOG_TO_FILE = typeof LOG_TO_FILE;
    export const IS_FILE_LOGGING_ENABLED = 'isFileLoggingEnabled';
    export type IS_FILE_LOGGING_ENABLED = typeof IS_FILE_LOGGING_ENABLED;
    export const GET_LOG_INFORMATION = 'getLogInformation';
    export type GET_LOG_INFORMATION = typeof GET_LOG_INFORMATION;
    export const GET_GZIPPED_LOG_FILE = 'getGzippedLogFiles';
    export type GET_GZIPPED_LOG_FILE = typeof GET_GZIPPED_LOG_FILE;
    export const SET_FILE_LOGGING_ENABLED_AND_RESTART = 'setFileLoggingEnabledAndRestart';
    export type SET_FILE_LOGGING_ENABLED_AND_RESTART = typeof SET_FILE_LOGGING_ENABLED_AND_RESTART;
    export const RESTART_APP = 'restartApp';
    export type RESTART_APP = typeof RESTART_APP;
    export const DELETE_PROFILE_AND_RESTART = 'deleteProfileAndRestart';
    export type DELETE_PROFILE_AND_RESTART = typeof DELETE_PROFILE_AND_RESTART;
    export const CREATE_PROFILE_SNAPSHOT = 'createProfileSnapshot';
    export type CREATE_PROFILE_SNAPSHOT = typeof CREATE_PROFILE_SNAPSHOT;
    export const REMOVE_OLD_PROFILES = 'removeOldProfiles';
    export type REMOVE_OLD_PROFILES = typeof REMOVE_OLD_PROFILES;
    export const GET_LATEST_PROFILE_PATH = 'getLatestProfilePath';
    export type GET_LATEST_PROFILE_PATH = typeof GET_LATEST_PROFILE_PATH;
    export const CLOSE_APP = 'closeApp';
    export type CLOSE_APP = typeof CLOSE_APP;
    export const UPDATE_APP_BADGE = 'updateAppBadge';
    export type UPDATE_APP_BADGE = typeof UPDATE_APP_BADGE;
    export const UPDATE_PUBLIC_KEY_PINS = 'updatePublicKeyPins';
    export type UPDATE_PUBLIC_KEY_PINS = typeof UPDATE_PUBLIC_KEY_PINS;
}
/**
 * ELECTRON
 * ========
 */
export type ElectronIpcCommand = (typeof ElectronIpcCommand)[keyof typeof ElectronIpcCommand];
export namespace BlobDownloadState {
    export const PERMANENT_FAILURE = 0;
    /** The blob download failed and should not be retried. */
    export type PERMANENT_FAILURE = typeof PERMANENT_FAILURE;
}
/**
 * DATABASE
 * ========
 */
/**
 * The blob download state.
 *
 * @generate convert
 */
export type BlobDownloadState = (typeof BlobDownloadState)[keyof typeof BlobDownloadState];
export namespace BlobDownloadStateUtils {
    export const ALL: ReadonlySet<BlobDownloadState> = new Set([
        BlobDownloadState.PERMANENT_FAILURE,
    ] as const);
    export function fromNumber(value: u53, fallback?: BlobDownloadState): BlobDownloadState {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as BlobDownloadState;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid BlobDownloadState`);
    }
    export function containsNumber(value: u53): value is BlobDownloadState {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is BlobDownloadState {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
}
export namespace Existence {
    export const ENSURED = 0;
    export type ENSURED = typeof ENSURED;
    export const UNKNOWN = 1;
    export type UNKNOWN = typeof UNKNOWN;
}
/**
 * UTILITY
 * =======
 */
/**
 * Whether it has been ensured that an entity exists or not.
 */
export type Existence = (typeof Existence)[keyof typeof Existence];
export namespace DeltaUpdateType {
    export const ADDED = 0;
    export type ADDED = typeof ADDED;
    export const DELETED = 1;
    export type DELETED = typeof DELETED;
    export const CLEARED = 2;
    export type CLEARED = typeof CLEARED;
}
/**
 * Delta update type.
 */
export type DeltaUpdateType = (typeof DeltaUpdateType)[keyof typeof DeltaUpdateType];
export namespace MouseEventButtons {
    export const NONE = 0;
    /** No button. */
    export type NONE = typeof NONE;
    export const PRIMARY = 1;
    /** Primary, usually the left button. */
    export type PRIMARY = typeof PRIMARY;
    export const SECONDARY = 2;
    /** Secondary, usually the right button. */
    export type SECONDARY = typeof SECONDARY;
    export const AUXILIARY = 4;
    /** Auxiliary, usually the middle/mouse wheel button. */
    export type AUXILIARY = typeof AUXILIARY;
    export const BACK = 8;
    /** 4th button, typically the "Browser Back" button. */
    export type BACK = typeof BACK;
    export const FORWARD = 16;
    /** 5th button, typically the "Browser Forward" button. */
    export type FORWARD = typeof FORWARD;
}
/**
 * Button value flags for `MouseEvent.buttons`, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
 */
export type MouseEventButtons = (typeof MouseEventButtons)[keyof typeof MouseEventButtons];
export namespace Browser {
    export const CHROME = 0;
    export type CHROME = typeof CHROME;
    export const CHROME_IOS = 1;
    export type CHROME_IOS = typeof CHROME_IOS;
    export const FIREFOX = 2;
    export type FIREFOX = typeof FIREFOX;
    export const FIREFOX_IOS = 3;
    export type FIREFOX_IOS = typeof FIREFOX_IOS;
    export const EDGE = 4;
    export type EDGE = typeof EDGE;
    export const OPERA = 5;
    export type OPERA = typeof OPERA;
    export const SAFARI = 6;
    export type SAFARI = typeof SAFARI;
    export const ELECTRON = 7;
    export type ELECTRON = typeof ELECTRON;
    export const UNKNOWN = 8;
    export type UNKNOWN = typeof UNKNOWN;
}
export type Browser = (typeof Browser)[keyof typeof Browser];
export namespace ImageRenderingType {
    export const REGULAR = 1;
    /**
     * Render as regular image.
     */
    export type REGULAR = typeof REGULAR;
    export const STICKER = 2;
    /**
     * Render as sticker (no background bubble).
     */
    export type STICKER = typeof STICKER;
}
/**
 * Rendering type of an image message.
 *
 * @generate convert name
 */
export type ImageRenderingType = (typeof ImageRenderingType)[keyof typeof ImageRenderingType];
export namespace ImageRenderingTypeUtils {
    export const ALL: ReadonlySet<ImageRenderingType> = new Set([
        ImageRenderingType.REGULAR,
        ImageRenderingType.STICKER,
    ] as const);
    export function fromNumber(value: u53, fallback?: ImageRenderingType): ImageRenderingType {
        if ((ALL as ReadonlySet<u53>).has(value)) {
            return value as ImageRenderingType;
        }
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`${value} is not a valid ImageRenderingType`);
    }
    export function containsNumber(value: u53): value is ImageRenderingType {
        return (ALL as ReadonlySet<u53>).has(value);
    }
    export function contains(value: unknown): value is ImageRenderingType {
        return typeof value === 'number' && (ALL as ReadonlySet<u53>).has(value);
    }
    export const NAME_OF = {
        [ImageRenderingType.REGULAR]: 'REGULAR',
        [ImageRenderingType.STICKER]: 'STICKER',
    } as const;
    export function nameOf<T extends u53>(value: T): string | undefined {
        return (NAME_OF as Record<u53, string | undefined>)[value];
    }
}
export namespace ImageType {
    export const JPEG = 1;
    export type JPEG = typeof JPEG;
    export const PNG = 2;
    export type PNG = typeof PNG;
    export const GIF = 3;
    export type GIF = typeof GIF;
    export const WEBP = 4;
    export type WEBP = typeof WEBP;
    export const AVIF = 5;
    export type AVIF = typeof AVIF;
}
/**
 * All supported image types.
 */
export type ImageType = (typeof ImageType)[keyof typeof ImageType];

// WARNING: This file has been generated by safe-enums. Do not modify it!
// vim: set readonly :
