// This file has been generated by structbuf. Do not modify it!
import * as base from '~/common/network/structbuf/base';
import type * as types from '~/common/types';
import * as utils from '../utils';

/**
 * ## End-to-End Encrypted Messages
 *
 * An end-to-end encrypted message can be sent or received once the handshake
 * was successful. Every end-to-end encrypted message is wrapped inside of a
 * [`container`](ref:payload.container) struct that is then encrypted and
 * wrapped by a payload [`legacy-message`](ref:payload.legacy-message) or
 * [`message-with-metadata-box`](ref:payload.message-with-metadata-box)
 * struct.
 *
 * ### Mitigating Replay
 *
 * To prevent replay attacks, a client must permanently store used nonces for
 * incoming and outgoing end-to-end encrypted messages. Messages reusing
 * previously used nonces must not be processed and discarded. One nonce
 * store for all end-to-end encrypted messages across different contacts is
 * sufficient.
 *
 * Note that it is still possible for the chat server to replay old messages to
 * a device whose database has been erased (e.g. when restoring a backup).
 * However, this is not applicable to forward security encrypted messages.
 *
 * ### Message ID
 *
 * Each message has an associated message ID. It is crucial to understand
 * that this is not a unique identifier across multiple conversations.
 * Unique identification of a message is determined by:
 *
 * - 1:1 Chats: The message ID in combination with the contact's Threema ID.
 * - Group Chats: The message ID in combination with the group creator's
 *   Threema ID and the group ID.
 * - Distribution Lists: The message ID with an artificial distribution list
 *   ID.
 *
 * If a message ID is received that already exists within the conversation,
 * the received message must be discarded.
 *
 * When a message is being quoted, it may only be looked up within the
 * associated conversation.
 *
 * ### Flags
 *
 * For each message, we will define _mandatory_ and _optional_ flags
 * referring to the `flags` field of the payload
 * [`legacy-message`](ref:payload.legacy-message) or
 * [`message-with-metadata-box`](ref:payload.message-with-metadata-box)
 * struct. A flag must be considered _mandatory_ unless it has been explicitly
 * marked _optional_.
 *
 * ### Handling
 *
 * Some messages require specific handling logic before sending or on
 * reception which will be described if necessary.
 *
 * ### Delivery Receipts
 *
 * There are two types of delivery receipts (sent using the
 * [`delivery-receipt`](ref:e2e.delivery-receipt) message):
 *
 * - Automatic: "received" and "read"
 * - Manual: "acknowledged" and "declined"
 *
 * For each message, we will define whether automatic delivery receipts should
 * be sent and whether it is eligible for sending manual delivery receipts
 * (e.g. acknowledge/decline). However, two general exceptions apply:
 *
 * 1. Automatic delivery receipts are not sent to group members (i.e. when
 *    any message struct is wrapped in a `group` message struct).
 * 2. Messages whose flags include `0x80` must not trigger any automatic
 *    delivery receipts.
 *
 * ### Blocking
 *
 * The sender Threema ID may be blocked explicitly (i.e. blocking a specific
 * Threema ID) or implicitly (blocking all unknown Threema IDs). This does not
 * require special handling on the server but instead is done entirely by the
 * clients.
 *
 * Note that the protocol does not distinguish between implicitly and
 * explicitly blocked Threema IDs. An implicitly blocked Threema ID (i.e.
 * blocking unknown contacts) must be treated the same as an explicitly blocked
 * Threema ID (i.e. blocking specific contacts).
 *
 * The UI must prevent users from composing or submitting messages towards a
 * blocked contact. In practise, this is only relevant for explicitly blocked
 * contacts as implicitly blocked contacts are already part of the contact list
 * when the conversation is being opened.
 *
 * In case a message is being received from a blocked sender, the message
 * should genereally be ignored. However, the following exceptions apply:
 *
 * - All group control messages must be handled as if the sender was not
 *   blocked.
 * - `csp-e2e.GroupJoinRequest` must be handled as if the sender was not
 *   blocked.
 *
 * Likewise, messages should not be sent to blocked receivers with the
 * following exceptions:
 *
 * - All group control messages must be sent as if the receiver was not
 *   blocked.
 * - `csp-e2e.GroupJoinResponse` must be sent as if the receiver was not
 *   blocked.
 *
 * ### Groups
 *
 * Groups are handled in a decentralised manner. Messages are sent to each
 * group member individually. On a technical level, a group is identified by
 * **both** the Threema ID of the creator and the random group ID the creator
 * chose. A group **must never** be identified by the group ID alone.
 *
 * Group messages are special containers wrapped around normal messages (it is
 * actually just a common header):
 *
 * - [`group-member-container`](ref:e2e.group-member-container): For group
 *   message communication between members, including the creator.
 * - [`group-creator-container`](ref:e2e.group-creator-container): For special
 *   messages that may only be sent from the creator to normal group members
 *   and vice versa.
 *
 * Group messages have special types in order to separate them from other
 * messages. These types also define which container must be used.
 *
 * The group members are determined by the
 * [`group-setup`](ref:e2e.group-setup) message and continuously updated by
 * any following [`group-leave`](ref:e2e.group-leave) messages. Any following
 * [`group-setup`](ref:e2e.group-setup) overrides the previous member state.
 *
 * Note that, unlike normal group messages, all group control messages must be
 * processed even if the sender has been [blocked](ref:e2e#blocking).
 * Analogous to that, all group control messages must be sent to
 * [blocked](ref:e2e#blocking) group members as well. This logic must always
 * be applied even if it's not explicitly mentioned by the description of a
 * group control message.
 *
 * Group control messages are not reflected to other devices in a device
 * group. Instead, the side effects of that message (the updated group) must
 * be reflected.
 *
 * ### Implicit Contact Creation
 *
 * When the user is added to a group, every unknown member of the group must be
 * added to the contact list with acquaintance level _group_. Messages from a
 * contact with any acquaintance level will not be implicitly blocked by a
 * _block unknown_ setting.
 *
 * The contact remains at the acquaintance level _group_ until a 1:1
 * conversation with that contact is being started by either side in which
 * case the acquaintance level should be changed to _direct_.
 *
 * A contact with acquaintance level _group_ should be removed automatically
 * once the last group the contact appears in is being removed, but only if
 * the associated group chat history is also being removed.
 *
 * ### Notes Group
 *
 * A group is identified as a _notes_ group if all of the following criteria
 * are met:
 *
 * 1. The user is the creator of the group.
 * 2. The group currently has no members beyond the user itself.
 * 3. The group is not marked as _left_.
 *
 * Messages in a _notes_ group are synchronised across devices but are not
 * sent to the chat server (since there are no other members). Therefore,
 * it is ideal for "notes to self", hence the name.
 *
 * A group seamlessly transforms into a _notes_ group and out of it given the
 * above criteria. Right now this can happen in three scenarios:
 *
 * - A _notes_ group is created explicitly (i.e. a group with only the user
 *   is being created).
 * - The user is the creator of a group and one or more members are being
 *   added in which case the _notes_ group transforms into a regular group.
 * - The user is the creator of a group whose members have just been removed
 *   (but the group has not been disbanded) in which case the group
 *   transforms into a _notes_ group.
 *
 * The UI should signal the _notes_ status of a group to the user.
 *
 * ### Sending
 *
 * A group message is encrypted and sent to each member individually.
 * However, the same [message ID](ref:e2e#message-id) must be used for those
 * individual messages (e.g. required for quoting). A group message is only
 * considered _sent_ once the server acknowledged reception of each individual
 * message.
 *
 * ### Receiving
 *
 * The following steps are defined as _Common Group Receive Steps_ and will
 * be applied in most cases for group messages:
 *
 * 1. Look up the group.
 * 2. If the group could not be found:
 *     1. If the user is the creator of the group (as alleged by the message),
 *        discard the message and abort these steps.
 *     2. Send a [`group-sync-request`](ref:e2e.group-sync-request) to the
 *        group creator, discard the message and abort these steps.
 * 3. If the group is marked as _left_:
 *     1. If the user is the creator of the group, send a
 *        [`group-setup`](ref:e2e.group-setup) with an empty members list back
 *        to the sender, discard the message and abort these steps.
 *     2. Send a [`group-leave`](ref:e2e.group-leave) back to the sender,
 *        discard the message and abort these steps.
 * 4. If the sender is not a member of the group:
 *    1. If the user is the creator of the group, send a
 *       [`group-setup`](ref:e2e.group-setup) with an empty members list back
 *       to the sender.
 *    2. Discard the message and abort these steps.
 *
 * This rule and any exceptions will be referenced/defined explicitly for each
 * message.
 *
 * Note that steps are not allowed to discard messages from blocked contacts
 * prior to running these steps if the message alters group state (group
 * control messages), or is stateful (i.e. introduces a poll, poll vote, or a
 * group call).
 *
 * ### Periodic Sync
 *
 * When the creator of a group...
 *
 * - is about to send a group conversation message, or
 * - did just receive a group conversation message,
 *
 * it must trigger a _group sync_ for this group if the last time the
 * _group sync_ was triggered is more than seven days ago.
 *
 * When a _group sync_ is triggered, the creator assumes it has received a
 * [`group-sync-request`](ref:e2e.group-sync-request) from every group member
 * and must now respond accordingly to each member of the group.
 *
 * A newly created group counts as an initial _group sync_ trigger. In other
 * words, the first group sync of a newly created group triggers seven days
 * in the future when one of the above described conditions is met.
 *
 * This provides a form of self-healing in case a device lost its group state
 * (e.g. due to a backup restore) and was unable to correct this mischief.
 *
 * [//]: # "TODO(SE-40): Group states"
 *
 * ### Blobs
 *
 * Since messages have a strict maximum size limitation, large binary blobs
 * are uploaded to the blob server. Blobs currently have a maximum size of
 * 50 MiB.
 *
 * When Multi-Device is activated, all Blobs must be downloaded via the
 * respective Blob Mirror unless explicitly stated otherwise.
 *
 * ### Image, Audio, Video vs. File
 *
 * Images, as well as audio and video sources can be either send as special
 * media messages or as files. When sending as a file, i.e. a
 * [`file`](ref:e2e.file) message struct with rendering type `0x00` (file), no
 * transcoding is necessary and no media type restrictions apply.
 *
 * Clients should intelligently choose between a media message and a file
 * message but always leave the final choice to the user.
 *
 * The following sections describe what restrictions apply and modifications
 * need to be made in case the source is sent as a media message, i.e. one
 * of the specialised (deprecated) media structs or a [`file`](ref:e2e.file)
 * message struct with rendering type `0x01` (media) or `0x02` (sticker).
 *
 * ### Images
 *
 * Images must be in JPEG format. When using the [`file`](ref:e2e.file)
 * message struct, the PNG and the GIF format is also allowed.
 *
 * Keep the format when resizing images or creating thumbnails, if possible
 * (e.g. if the source is a JPEG, make the thumbnail a JPEG). When the format
 * cannot be kept, use PNG for source images with transparency or
 * lossless encoding (e.g. screenshots) and JPEG for images without
 * transparency or lossy encoding (e.g. photos).
 *
 * Recommended maximum dimensions:
 *
 * - Small: 640x640
 * - Medium: 1024x1024
 * - Large: 1600x1600
 * - Extra Large: 2592x2592
 * - Original: As is
 *
 * ### Thumbnails
 *
 * Apply the logic described for images to all thumbnails with recommended
 * maximum dimensions of 512x512.
 *
 * ### User Profile Distribution
 *
 * The shareable part of the user profile consists of the user's public
 * nickname and the profile picture:
 *
 * - The nickname is sent along with outgoing messages as `sender-nickname`
 *   inside the [`legacy-message`](ref:payload.legacy-message) or as part of
 *   the metadata in
 *   [`message-with-metadata-box`](ref:payload.message-with-metadata-box).
 * - The profile picture is distributed as described in
 *   [Profile Picture Distribution](ref:e2e#profile-picture-distribution).
 *
 * Whether user profile distribution should be triggered by an outgoing message
 * is specified in the description of every message type below.
 *
 * ### Profile Pictures
 *
 * Apply the logic described for images to all profile pictures with
 * recommended maximum dimensions of 512x512 with a square aspect ratio.
 *
 * #### Profile Picture Distribution
 *
 * Every time a message is being sent to a specific contact or a group of
 * contacts, the sender needs to evaluate whether the profile picture needs to
 * be sent. If the receiver of the message is a group, the evaluation needs to
 * be done for each contact of that group:
 *
 * 1. If the message [does not allow user profile
 *    distribution](ref:e2e#user-profile-distribution), abort these steps.
 * 2. If the contact's Threema ID is `ECHOECHO` or a Threema Gateway ID
 *    (starts with a `*`), abort these steps.
 * 3. Ensure the app settings require the profile picture to be distributed to
 *    all contacts or to that contact specifically. Otherwise, abort these
 *    steps.
 * 4. If no cached profile picture blob exists or the cache expired, encrypt
 *    the profile picture with a random symmetric key and upload it to the blob
 *    server. Cache both the blob ID and the key with an expiration date
 *    of seven days.
 * 5. If the currently cached blob ID equals the blob ID that was most
 *    recently distributed to the contact, abort these steps.
 * 6. Send a [`set-profile-picture`](ref:e2e.set-profile-picture) message to
 *    the contact using the cached blob ID and key.
 * 7. Store the cached blob ID as the most recently used blob ID for that
 *    contact.
 *
 * When the user changes the profile picture, remove the cached profile picture
 * (i.e. any associated blob ID and key).
 *
 * #### Profile Picture Sharing Settings
 *
 * In the client settings, there are three profile picture sharing options that
 * the user can choose from:
 *
 * - Share with nobody
 * - Share with everybody you write to
 * - Share with selected contacts only
 *
 * The default is to share the profile picture with everyone.
 *
 * #### Contact Profile Picture Precedence
 *
 * There are three different sources of profile pictures, ordered by
 * precedence:
 *
 * 1. _contact-defined_: Set by the contact, distributed through a
 *    [`set-profile-picture`](ref:e2e.set-profile-picture) message.
 * 2. _gateway-defined_: Set by the creator in the Threema Gateway (or Threema
 *    Broadcast) control panel and distributed through `avatar.threema.ch`.
 *    Only applicable to Threema Gateway IDs (starting with a `*`).
 * 3. _user-defined_: Set by the app user for this contact or imported from
 *    the address book. Applicable to all Threema IDs which are not Threema
 *    Gateway IDs.
 *
 * The following steps are defined as _Contact Profile Picture Selection Steps_
 * and will be applied to determine the contact's profile picture that should
 * be displayed:
 *
 * 1. Let `id` be the Threema ID of the contact.
 * 2. If the _contact-defined_ picture is set for the contact, apply it and
 *    abort these steps.
 * 3. If `id` starts with a `*` (is a Threema Gateway ID) and the
 *    _gateway-defined_ picture is set for the contact, apply it and abort
 *    these steps.
 * 4. If `id` does not start with `*` and the _user-defined_ picture is set
 *    for the contact, apply it and abort these steps.
 * 5. Apply a fallback picture.
 *
 * #### Recurring Gateway Contact Profile Picture Refresh
 *
 * For contacts with a Threema Gateway ID (starting with a `*`), the profile
 * picture needs to be fetched recurringly:
 *
 * 1. Fetch the profile picture for the ID from `avatar.threema.ch`.
 * 2. If no profile picture could be found, schedule the next refresh in 24h
 *    and abort these steps.
 * 3. Store the profile picture as the _gateway-defined_ picture.
 * 4. Schedule the next refresh according to the `expires` header of the HTTP
 *    response.
 * 5. Run the _Contact Profile Picture Selection Steps_ for this contact.
 *
 * ### Audio
 *
 * Audio must be in AAC format.
 *
 * If the source is already in AAC, no transcoding is necessary. Otherwise,
 * the recommended transcoding settings are: Bitrate 128 kbit/s, 2 channels.
 *
 * When recording audio (i.e. a voice message), the recommended recording
 * settings are: Sample rate 44.1 kHz, bitrate 32 kbit/s, 1 channel.
 *
 * ### Video
 *
 * Videos must be encoded in H.264 and the MP4 container format.
 *
 * Recommended encoding settings for all videos:
 *
 * - Low: 480x480, scale by maintaining aspect ratio to nearest multiple
 *   of 16px. Video bitrate 384 kbit/s, audio bitrate 32 kbit/s (2
 *   channels). Baseline Profile, Level 3.1.
 * - High: 848x848, scale by maintaining aspect ratio to nearest multiple
 *   of 16px. Video bitrate 1500 kbit/s, audio bitrate 64 kbit/s (2
 *   channels). Baseline Profile, Level 3.1.
 * - Original: As is. Still needs transcoding in case a different codec has
 *   been used.
 *
 * When recording a video, the following recording settings are recommended
 * to avoid post-reencoding: 1280x720 / 720x1280. Video bitrate 2000 kbit/s
 * at 30 fps, audio bitrate 128 kbit/s (2 channels).
 *
 * ### Call Features
 *
 * Call features are transmitted within either a
 * [`call-offer`](ref:e2e.call-offer) or a [`call-answer`](ref:e2e.call-answer)
 * message. It is an optional object containing the below defined fields. If
 * the object is not provided, assume an empty features object.
 *
 * - Video Support (`'video'`): Set this field to `null` or an empty object if
 *   video calls are enabled. If either side omits this field, video support
 *   is disabled for the upcoming call.
 */

/**
 * Contains an end-to-end encrypted message.
 */
export interface ContainerLike {
    /**
     * Type of the message (`common.CspE2eMessageType`).
     */
    readonly type: types.u8;

    /**
     * Inner message. Needs to be parsed according to the `type` field.
     * Padded with a random amount from 1 to 255 bytes in [PKCS#7
     * format](https://datatracker.ietf.org/doc/html/rfc5652#section-6.3).
     *
     * Additionally, for security reasons, the total size of `padded-data`
     * should be at least 32 bytes, to avoid leaking information about the
     * contents.
     *
     * Example padding (hex representation):
     *
     * - 1 byte: `01`
     * - 3 bytes: `030303`
     * - 10 bytes: `0A0A0A0A0A0A0A0A0A0A`
     *
     * To add padding without information leaks, run the following steps:
     *
     * 1. Let `data` be the data to be padded.
     * 2. Let `pad-length` be a random number between (inclusive) 1 and 255.
     * 3. If the sum of the byte length of `data` and `pad-length` is less
     *    than 32, update `pad-length` so the sum is precisely 32.
     * 4. Let `pad-byte` be the encoded unsigned 8-bit integer
     *    representation of `pad-length`.
     * 5. Let `padded-data` be the padded data by adding `pad-length`
     *    trailing `pad-byte` bytes to `data`.
     *
     * To remove padding:
     *
     * 1. Let `pad-length` be the decoded unsigned 8-bit integer
     *    representation of the last byte of `padded-data`.
     * 2. Let `data` be the unpadded data by ignoring the trailing
     *    `pad-length` bytes of `padded-data`.
     */
    readonly paddedData: Uint8Array;
}

/**
 * Encodable of {@link ContainerLike}.
 */
interface ContainerEncodable_ {
    /**
     * 'type' field value or encoder. See {@link ContainerLike#type} for
     * the field's description.
     */
    readonly type: types.u8;

    /**
     * 'padded-data' field value or encoder. See {@link ContainerLike#paddedData} for
     * the field's description.
     */
    readonly paddedData: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for ContainerEncodable.
 */
export type ContainerEncodable = types.WeakOpaque<
    ContainerEncodable_,
    {readonly ContainerEncodable: unique symbol}
>;

/** @inheritdoc */
export class Container extends base.Struct implements ContainerLike {
    private readonly _array: Uint8Array;

    /**
     * Create a Container from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a container struct from an array.
     *
     * @param array Array to decode from.
     * @returns Container instance.
     */
    public static decode(array: Uint8Array): Container {
        return new Container(array);
    }

    /**
     * Encode a container struct into an array.
     *
     * @param struct ContainerEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<ContainerEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        let offset = 1;

        // Encode `type`
        array[0] = struct.type;

        // Encode `padded-data`
        offset += utils.encodeBytes(struct.paddedData, array, offset);

        return array.subarray(0, offset);
    }

    /**
     * Get the amount of bytes that would be written when encoding a container struct into an
     * array.
     *
     * @param struct ContainerEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<ContainerEncodable, 'byteLength'>,
    ): types.u53 {
        let offset = 1;
        offset += utils.getByteLength(struct.paddedData);
        return offset;
    }

    /**
     * 'type' field accessor. See {@link ContainerLike#type} for the
     * field's description.
     */
    public get type(): types.u8 {
        return this._array[0];
    }

    /**
     * 'padded-data' field accessor. See {@link ContainerLike#paddedData} for the
     * field's description.
     */
    public get paddedData(): Uint8Array {
        return this._array.subarray(1);
    }

    /**
     * Create a snapshot of ContainerLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns ContainerLike snapshot.
     */
    public snapshot(): ContainerLike {
        return {
            type: this.type,
            paddedData: this.paddedData,
        };
    }

    /**
     * Create a clone of ContainerLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns ContainerLike clone.
     */
    public clone(): Container {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new Container(array);
    }
}

/**
 * Container that is wrapped around some special group messages sent by the
 * creator to normal group members and vice versa.
 */
export interface GroupCreatorContainerLike {
    /**
     * 8 byte random group ID. Uniquely identifies the group when combined
     * with the creator's Threema ID.
     */
    readonly groupId: types.u64;

    /**
     * Inner message struct.
     */
    readonly innerData: Uint8Array;
}

/**
 * Encodable of {@link GroupCreatorContainerLike}.
 */
interface GroupCreatorContainerEncodable_ {
    /**
     * 'group-id' field value or encoder. See {@link GroupCreatorContainerLike#groupId} for
     * the field's description.
     */
    readonly groupId: types.u64;

    /**
     * 'inner-data' field value or encoder. See {@link GroupCreatorContainerLike#innerData} for
     * the field's description.
     */
    readonly innerData: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for GroupCreatorContainerEncodable.
 */
export type GroupCreatorContainerEncodable = types.WeakOpaque<
    GroupCreatorContainerEncodable_,
    {readonly GroupCreatorContainerEncodable: unique symbol}
>;

/** @inheritdoc */
export class GroupCreatorContainer extends base.Struct implements GroupCreatorContainerLike {
    private readonly _array: Uint8Array;
    private readonly _view: DataView;

    /**
     * Create a GroupCreatorContainer from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
        this._view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    }

    /**
     * Decode a group-creator-container struct from an array.
     *
     * @param array Array to decode from.
     * @returns GroupCreatorContainer instance.
     */
    public static decode(array: Uint8Array): GroupCreatorContainer {
        return new GroupCreatorContainer(array);
    }

    /**
     * Encode a group-creator-container struct into an array.
     *
     * @param struct GroupCreatorContainerEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<GroupCreatorContainerEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        const view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        let offset = 8;

        // Encode `group-id`
        view.setBigUint64(0, struct.groupId, true);

        // Encode `inner-data`
        offset += utils.encodeBytes(struct.innerData, array, offset);

        return array.subarray(0, offset);
    }

    /**
     * Get the amount of bytes that would be written when encoding a group-creator-container struct into an
     * array.
     *
     * @param struct GroupCreatorContainerEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<GroupCreatorContainerEncodable, 'byteLength'>,
    ): types.u53 {
        let offset = 8;
        offset += utils.getByteLength(struct.innerData);
        return offset;
    }

    /**
     * 'group-id' field accessor. See {@link GroupCreatorContainerLike#groupId} for the
     * field's description.
     */
    public get groupId(): types.u64 {
        return this._view.getBigUint64(0, true);
    }

    /**
     * 'inner-data' field accessor. See {@link GroupCreatorContainerLike#innerData} for the
     * field's description.
     */
    public get innerData(): Uint8Array {
        return this._array.subarray(8);
    }

    /**
     * Create a snapshot of GroupCreatorContainerLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns GroupCreatorContainerLike snapshot.
     */
    public snapshot(): GroupCreatorContainerLike {
        return {
            groupId: this.groupId,
            innerData: this.innerData,
        };
    }

    /**
     * Create a clone of GroupCreatorContainerLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns GroupCreatorContainerLike clone.
     */
    public clone(): GroupCreatorContainer {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new GroupCreatorContainer(array);
    }
}

/**
 * Container that is wrapped around most messages sent by group members to
 * other group members.
 */
export interface GroupMemberContainerLike {
    /**
     * The group creator's Threema ID.
     */
    readonly creatorIdentity: Uint8Array;

    /**
     * 8 byte random group ID assigned to the group by the creator.
     */
    readonly groupId: types.u64;

    /**
     * Inner message struct.
     */
    readonly innerData: Uint8Array;
}

/**
 * Encodable of {@link GroupMemberContainerLike}.
 */
interface GroupMemberContainerEncodable_ {
    /**
     * 'creator-identity' field value or encoder. See {@link GroupMemberContainerLike#creatorIdentity} for
     * the field's description.
     */
    readonly creatorIdentity: Uint8Array | types.ByteLengthEncoder;

    /**
     * 'group-id' field value or encoder. See {@link GroupMemberContainerLike#groupId} for
     * the field's description.
     */
    readonly groupId: types.u64;

    /**
     * 'inner-data' field value or encoder. See {@link GroupMemberContainerLike#innerData} for
     * the field's description.
     */
    readonly innerData: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for GroupMemberContainerEncodable.
 */
export type GroupMemberContainerEncodable = types.WeakOpaque<
    GroupMemberContainerEncodable_,
    {readonly GroupMemberContainerEncodable: unique symbol}
>;

/** @inheritdoc */
export class GroupMemberContainer extends base.Struct implements GroupMemberContainerLike {
    private readonly _array: Uint8Array;
    private readonly _view: DataView;

    /**
     * Create a GroupMemberContainer from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
        this._view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    }

    /**
     * Decode a group-member-container struct from an array.
     *
     * @param array Array to decode from.
     * @returns GroupMemberContainer instance.
     */
    public static decode(array: Uint8Array): GroupMemberContainer {
        return new GroupMemberContainer(array);
    }

    /**
     * Encode a group-member-container struct into an array.
     *
     * @param struct GroupMemberContainerEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<GroupMemberContainerEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        const view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        let offset = 16;

        // Encode `creator-identity`
        utils.encodeBytes(struct.creatorIdentity, array, 0);

        // Encode `group-id`
        view.setBigUint64(8, struct.groupId, true);

        // Encode `inner-data`
        offset += utils.encodeBytes(struct.innerData, array, offset);

        return array.subarray(0, offset);
    }

    /**
     * Get the amount of bytes that would be written when encoding a group-member-container struct into an
     * array.
     *
     * @param struct GroupMemberContainerEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<GroupMemberContainerEncodable, 'byteLength'>,
    ): types.u53 {
        let offset = 16;
        offset += utils.getByteLength(struct.innerData);
        return offset;
    }

    /**
     * 'creator-identity' field accessor. See {@link GroupMemberContainerLike#creatorIdentity} for the
     * field's description.
     */
    public get creatorIdentity(): Uint8Array {
        const offset = 0;
        return this._array.subarray(offset, offset + 8);
    }

    /**
     * 'group-id' field accessor. See {@link GroupMemberContainerLike#groupId} for the
     * field's description.
     */
    public get groupId(): types.u64 {
        return this._view.getBigUint64(8, true);
    }

    /**
     * 'inner-data' field accessor. See {@link GroupMemberContainerLike#innerData} for the
     * field's description.
     */
    public get innerData(): Uint8Array {
        return this._array.subarray(16);
    }

    /**
     * Create a snapshot of GroupMemberContainerLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns GroupMemberContainerLike snapshot.
     */
    public snapshot(): GroupMemberContainerLike {
        return {
            creatorIdentity: this.creatorIdentity,
            groupId: this.groupId,
            innerData: this.innerData,
        };
    }

    /**
     * Create a clone of GroupMemberContainerLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns GroupMemberContainerLike clone.
     */
    public clone(): GroupMemberContainer {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new GroupMemberContainer(array);
    }
}

/**
 * A text message.
 *
 * **Flags:**
 *   - `0x01`: Send push notification.
 *
 * **Delivery receipts:** Automatic: Yes. Manual: Yes.
 *
 * **User profile distribution:** Yes.
 *
 * **Reflect:** Incoming: Yes. Outgoing: Yes.
 *
 * When receiving this message as a 1:1 conversation message:
 *
 * 1. Add the message to the associated 1:1 conversation.
 *
 * When receiving this message as a group message (wrapped by
 * [`group-member-container`](ref:e2e.group-member-container)):
 *
 * 1. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the
 *    message has been discarded, abort these steps.
 * 2. Add the message to the associated group conversation.
 */
export interface TextLike {
    /**
     * UTF-8 encoded text.
     */
    readonly text: Uint8Array;
}

/**
 * Encodable of {@link TextLike}.
 */
interface TextEncodable_ {
    /**
     * 'text' field value or encoder. See {@link TextLike#text} for
     * the field's description.
     */
    readonly text: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for TextEncodable.
 */
export type TextEncodable = types.WeakOpaque<
    TextEncodable_,
    {readonly TextEncodable: unique symbol}
>;

/** @inheritdoc */
export class Text extends base.Struct implements TextLike {
    private readonly _array: Uint8Array;

    /**
     * Create a Text from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a text struct from an array.
     *
     * @param array Array to decode from.
     * @returns Text instance.
     */
    public static decode(array: Uint8Array): Text {
        return new Text(array);
    }

    /**
     * Encode a text struct into an array.
     *
     * @param struct TextEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<TextEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        let offset = 0;

        // Encode `text`
        offset += utils.encodeBytes(struct.text, array, offset);

        return array.subarray(0, offset);
    }

    /**
     * Get the amount of bytes that would be written when encoding a text struct into an
     * array.
     *
     * @param struct TextEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(struct: types.EncoderPick<TextEncodable, 'byteLength'>): types.u53 {
        let offset = 0;
        offset += utils.getByteLength(struct.text);
        return offset;
    }

    /**
     * 'text' field accessor. See {@link TextLike#text} for the
     * field's description.
     */
    public get text(): Uint8Array {
        return this._array.subarray(0);
    }

    /**
     * Create a snapshot of TextLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns TextLike snapshot.
     */
    public snapshot(): TextLike {
        return {
            text: this.text,
        };
    }

    /**
     * Create a clone of TextLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns TextLike clone.
     */
    public clone(): Text {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new Text(array);
    }
}

/**
 * An image message.
 *
 * Note: This message is deprecated and may be phased out eventually. When
 *       sending images, use the [`file`](ref:e2e.file) message with the
 *       rendering type `0x01` (media).
 *
 * **Flags:**
 *   - `0x01`: Send push notification.
 *
 * **Delivery receipts:** Automatic: Yes. Manual: Yes.
 *
 * **User profile distribution:** Yes.
 *
 * **Reflect:** Incoming: Yes. Outgoing: Yes.
 *
 * The image must be in JPEG format, is uploaded to the blob server and
 * encrypted by:
 *
 *     XSalsa20-Poly1305(
 *       key=X25519HSalsa20(<sender.CK>.secret, <receiver.CK>.public),
 *       nonce=<deprecated-image.nonce>,
 *     )
 *
 * When receiving this message:
 *
 * 1. If desired, download the image data from the blob server and request
 *    the blob to be removed.
 * 2. Add the message to the associated 1:1 conversation.
 */
export interface DeprecatedImageLike {
    /**
     * Blob ID to obtain the image data.
     */
    readonly imageBlobId: Uint8Array;

    /**
     * Image size in bytes.
     */
    readonly imageSize: types.u32;

    /**
     * Random nonce used to encrypt the image data.
     */
    readonly nonce: Uint8Array;
}

/**
 * Encodable of {@link DeprecatedImageLike}.
 */
interface DeprecatedImageEncodable_ {
    /**
     * 'image-blob-id' field value or encoder. See {@link DeprecatedImageLike#imageBlobId} for
     * the field's description.
     */
    readonly imageBlobId: Uint8Array | types.ByteLengthEncoder;

    /**
     * 'image-size' field value or encoder. See {@link DeprecatedImageLike#imageSize} for
     * the field's description.
     */
    readonly imageSize: types.u32;

    /**
     * 'nonce' field value or encoder. See {@link DeprecatedImageLike#nonce} for
     * the field's description.
     */
    readonly nonce: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for DeprecatedImageEncodable.
 */
export type DeprecatedImageEncodable = types.WeakOpaque<
    DeprecatedImageEncodable_,
    {readonly DeprecatedImageEncodable: unique symbol}
>;

/** @inheritdoc */
export class DeprecatedImage extends base.Struct implements DeprecatedImageLike {
    private readonly _array: Uint8Array;
    private readonly _view: DataView;

    /**
     * Create a DeprecatedImage from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
        this._view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    }

    /**
     * Decode a deprecated-image struct from an array.
     *
     * @param array Array to decode from.
     * @returns DeprecatedImage instance.
     */
    public static decode(array: Uint8Array): DeprecatedImage {
        return new DeprecatedImage(array);
    }

    /**
     * Encode a deprecated-image struct into an array.
     *
     * @param struct DeprecatedImageEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<DeprecatedImageEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        const view = new DataView(array.buffer, array.byteOffset, array.byteLength);

        // Encode `image-blob-id`
        utils.encodeBytes(struct.imageBlobId, array, 0);

        // Encode `image-size`
        view.setUint32(16, struct.imageSize, true);

        // Encode `nonce`
        utils.encodeBytes(struct.nonce, array, 20);

        return array.subarray(0, 44);
    }

    /**
     * Get the amount of bytes that would be written when encoding a deprecated-image struct into an
     * array.
     *
     * @param struct DeprecatedImageEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<DeprecatedImageEncodable, 'byteLength'>,
    ): types.u53 {
        return 44;
    }

    /**
     * 'image-blob-id' field accessor. See {@link DeprecatedImageLike#imageBlobId} for the
     * field's description.
     */
    public get imageBlobId(): Uint8Array {
        const offset = 0;
        return this._array.subarray(offset, offset + 16);
    }

    /**
     * 'image-size' field accessor. See {@link DeprecatedImageLike#imageSize} for the
     * field's description.
     */
    public get imageSize(): types.u32 {
        return this._view.getUint32(16, true);
    }

    /**
     * 'nonce' field accessor. See {@link DeprecatedImageLike#nonce} for the
     * field's description.
     */
    public get nonce(): Uint8Array {
        const offset = 20;
        return this._array.subarray(offset, offset + 24);
    }

    /**
     * Create a snapshot of DeprecatedImageLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns DeprecatedImageLike snapshot.
     */
    public snapshot(): DeprecatedImageLike {
        return {
            imageBlobId: this.imageBlobId,
            imageSize: this.imageSize,
            nonce: this.nonce,
        };
    }

    /**
     * Create a clone of DeprecatedImageLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns DeprecatedImageLike clone.
     */
    public clone(): DeprecatedImage {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new DeprecatedImage(array);
    }
}

/**
 * An image message (only used by groups).
 *
 * Note: This message is deprecated and may be phased out eventually. When
 *       sending images, use the [`file`](ref:e2e.file) message with the
 *       rendering type `0x01` (media).
 *
 * **Flags:**
 *   - `0x01`: Send push notification.
 *
 * **Delivery receipts:** Automatic: No. Manual: Yes.
 *
 * **User profile distribution:** Yes.
 *
 * **Reflect:** Incoming: Yes. Outgoing: Yes.
 *
 * The image must be in JPEG format, is uploaded to the blob server and
 * encrypted by:
 *
 *     XSalsa20-Poly1305(key=<deprecated-group-image.key>, nonce=00..01)
 *
 * When receiving this message (wrapped by
 * [`group-member-container`](ref:e2e.group-member-container)):
 *
 * 1. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the
 *    message has been discarded, abort these steps.
 * 2. Download thumbnail and file (if desired) data from the blob server. Do
 *    not request the blobs to be removed.
 * 3. Add the message to the associated group conversation.
 */
export interface DeprecatedGroupImageLike {
    /**
     * Blob ID to obtain the image data.
     */
    readonly imageBlobId: Uint8Array;

    /**
     * Image size in bytes.
     */
    readonly imageSize: types.u32;

    /**
     * Random symmetric key used to encrypt the image data.
     */
    readonly key: Uint8Array;
}

/**
 * Encodable of {@link DeprecatedGroupImageLike}.
 */
interface DeprecatedGroupImageEncodable_ {
    /**
     * 'image-blob-id' field value or encoder. See {@link DeprecatedGroupImageLike#imageBlobId} for
     * the field's description.
     */
    readonly imageBlobId: Uint8Array | types.ByteLengthEncoder;

    /**
     * 'image-size' field value or encoder. See {@link DeprecatedGroupImageLike#imageSize} for
     * the field's description.
     */
    readonly imageSize: types.u32;

    /**
     * 'key' field value or encoder. See {@link DeprecatedGroupImageLike#key} for
     * the field's description.
     */
    readonly key: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for DeprecatedGroupImageEncodable.
 */
export type DeprecatedGroupImageEncodable = types.WeakOpaque<
    DeprecatedGroupImageEncodable_,
    {readonly DeprecatedGroupImageEncodable: unique symbol}
>;

/** @inheritdoc */
export class DeprecatedGroupImage extends base.Struct implements DeprecatedGroupImageLike {
    private readonly _array: Uint8Array;
    private readonly _view: DataView;

    /**
     * Create a DeprecatedGroupImage from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
        this._view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    }

    /**
     * Decode a deprecated-group-image struct from an array.
     *
     * @param array Array to decode from.
     * @returns DeprecatedGroupImage instance.
     */
    public static decode(array: Uint8Array): DeprecatedGroupImage {
        return new DeprecatedGroupImage(array);
    }

    /**
     * Encode a deprecated-group-image struct into an array.
     *
     * @param struct DeprecatedGroupImageEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<DeprecatedGroupImageEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        const view = new DataView(array.buffer, array.byteOffset, array.byteLength);

        // Encode `image-blob-id`
        utils.encodeBytes(struct.imageBlobId, array, 0);

        // Encode `image-size`
        view.setUint32(16, struct.imageSize, true);

        // Encode `key`
        utils.encodeBytes(struct.key, array, 20);

        return array.subarray(0, 52);
    }

    /**
     * Get the amount of bytes that would be written when encoding a deprecated-group-image struct into an
     * array.
     *
     * @param struct DeprecatedGroupImageEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<DeprecatedGroupImageEncodable, 'byteLength'>,
    ): types.u53 {
        return 52;
    }

    /**
     * 'image-blob-id' field accessor. See {@link DeprecatedGroupImageLike#imageBlobId} for the
     * field's description.
     */
    public get imageBlobId(): Uint8Array {
        const offset = 0;
        return this._array.subarray(offset, offset + 16);
    }

    /**
     * 'image-size' field accessor. See {@link DeprecatedGroupImageLike#imageSize} for the
     * field's description.
     */
    public get imageSize(): types.u32 {
        return this._view.getUint32(16, true);
    }

    /**
     * 'key' field accessor. See {@link DeprecatedGroupImageLike#key} for the
     * field's description.
     */
    public get key(): Uint8Array {
        const offset = 20;
        return this._array.subarray(offset, offset + 32);
    }

    /**
     * Create a snapshot of DeprecatedGroupImageLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns DeprecatedGroupImageLike snapshot.
     */
    public snapshot(): DeprecatedGroupImageLike {
        return {
            imageBlobId: this.imageBlobId,
            imageSize: this.imageSize,
            key: this.key,
        };
    }

    /**
     * Create a clone of DeprecatedGroupImageLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns DeprecatedGroupImageLike clone.
     */
    public clone(): DeprecatedGroupImage {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new DeprecatedGroupImage(array);
    }
}

/**
 * A location message.
 *
 * **Flags:**
 *   - `0x01`: Send push notification.
 *
 * **Delivery receipts:** Automatic: Yes. Manual: Yes.
 *
 * **User profile distribution:** Yes.
 *
 * **Reflect:** Incoming: Yes. Outgoing: Yes.
 *
 * When receiving this message as a group message (wrapped by
 * [`group-member-container`](ref:e2e.group-member-container)):
 *
 * 1. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the
 *    message has been discarded, abort these steps.
 * 2. Add the message to the associated group conversation.
 */
export interface LocationLike {
    /**
     * Location coordinates and meta information encoded in comma- and
     * line-separated UTF-8:
     *
     *     <latitude>,<longitude>[,<accuracy>]
     *
     * or
     *
     *     <latitude>,<longitude>[,<accuracy>]
     *     <address>
     *
     * or
     *
     *     <latitude>,<longitude>[,<accuracy>]
     *     <name>
     *     <address>
     *
     * Values:
     *
     * - `latitude` and `longitude` are the geographic coordinates
     *   represented in a WGS-84 string.
     * - `accuracy` is the accuracy in meters represented by a floating
     *   point number formatted as a string.
     * - `address` is a full address. If it contains multiple lines, each
     *   line feed must be escaped (literal `\n`).
     * - `name` is the name of a point of interest.
     *
     * _Latitude_ and _longitude_ must always be present while _accuracy_
     * is optional and should only be provided when the current location of
     * the device is being sent. These values are comma-separated.
     *
     * Following values are optional and separated by line feeds (`\n`).
     * This may be either:
     *
     * - a single line containing the _address_ representing the closest
     *   address matching the coordinates, or
     * - two lines containing a point of interest _name_ and _address_
     *   (which means that the coordinates refer to the point of interest).
     */
    readonly location: Uint8Array;
}

/**
 * Encodable of {@link LocationLike}.
 */
interface LocationEncodable_ {
    /**
     * 'location' field value or encoder. See {@link LocationLike#location} for
     * the field's description.
     */
    readonly location: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for LocationEncodable.
 */
export type LocationEncodable = types.WeakOpaque<
    LocationEncodable_,
    {readonly LocationEncodable: unique symbol}
>;

/** @inheritdoc */
export class Location extends base.Struct implements LocationLike {
    private readonly _array: Uint8Array;

    /**
     * Create a Location from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a location struct from an array.
     *
     * @param array Array to decode from.
     * @returns Location instance.
     */
    public static decode(array: Uint8Array): Location {
        return new Location(array);
    }

    /**
     * Encode a location struct into an array.
     *
     * @param struct LocationEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<LocationEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        let offset = 0;

        // Encode `location`
        offset += utils.encodeBytes(struct.location, array, offset);

        return array.subarray(0, offset);
    }

    /**
     * Get the amount of bytes that would be written when encoding a location struct into an
     * array.
     *
     * @param struct LocationEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<LocationEncodable, 'byteLength'>,
    ): types.u53 {
        let offset = 0;
        offset += utils.getByteLength(struct.location);
        return offset;
    }

    /**
     * 'location' field accessor. See {@link LocationLike#location} for the
     * field's description.
     */
    public get location(): Uint8Array {
        return this._array.subarray(0);
    }

    /**
     * Create a snapshot of LocationLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns LocationLike snapshot.
     */
    public snapshot(): LocationLike {
        return {
            location: this.location,
        };
    }

    /**
     * Create a clone of LocationLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns LocationLike clone.
     */
    public clone(): Location {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new Location(array);
    }
}

/**
 * An audio message.
 *
 * Note: This message is deprecated and may be phased out eventually. When
 *       sending audio, use the [`file`](ref:e2e.file) message with the
 *       rendering type `0x01` (media).
 *
 * **Flags:**
 *   - `0x01`: Send push notification.
 *
 * **Delivery receipts:** Automatic: Yes. Manual: Yes.
 *
 * **User profile distribution:** Yes.
 *
 * **Reflect:** Incoming: Yes. Outgoing: Yes.
 *
 * The audio is uploaded to the blob server and encrypted by:
 *
 *     XSalsa20-Poly1305(key=<deprecated-audio.key>, nonce=00..01)
 *
 * When receiving this message as a 1:1 conversation message:
 *
 * 1. If desired, download the audio data from the blob server and request
 *    the blob to be removed.
 * 2. Add the message to the associated 1:1 conversation.
 *
 * When receiving this message as a group message (wrapped by
 * [`group-member-container`](ref:e2e.group-member-container)):
 *
 * 1. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the
 *    message has been discarded, abort these steps.
 * 2. If desired, download the audio data from the blob server. Do not
 *    request the blob to be removed.
 * 3. Add the message to the associated group conversation.
 */
export interface DeprecatedAudioLike {
    /**
     * Audio duration in seconds.
     */
    readonly duration: types.u16;

    /**
     * Blob ID to obtain the audio data.
     */
    readonly audioBlobId: Uint8Array;

    /**
     * Audio size in bytes.
     */
    readonly audioSize: types.u32;

    /**
     * Random symmetric key used to encrypt the audio data.
     */
    readonly key: Uint8Array;
}

/**
 * Encodable of {@link DeprecatedAudioLike}.
 */
interface DeprecatedAudioEncodable_ {
    /**
     * 'duration' field value or encoder. See {@link DeprecatedAudioLike#duration} for
     * the field's description.
     */
    readonly duration: types.u16;

    /**
     * 'audio-blob-id' field value or encoder. See {@link DeprecatedAudioLike#audioBlobId} for
     * the field's description.
     */
    readonly audioBlobId: Uint8Array | types.ByteLengthEncoder;

    /**
     * 'audio-size' field value or encoder. See {@link DeprecatedAudioLike#audioSize} for
     * the field's description.
     */
    readonly audioSize: types.u32;

    /**
     * 'key' field value or encoder. See {@link DeprecatedAudioLike#key} for
     * the field's description.
     */
    readonly key: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for DeprecatedAudioEncodable.
 */
export type DeprecatedAudioEncodable = types.WeakOpaque<
    DeprecatedAudioEncodable_,
    {readonly DeprecatedAudioEncodable: unique symbol}
>;

/** @inheritdoc */
export class DeprecatedAudio extends base.Struct implements DeprecatedAudioLike {
    private readonly _array: Uint8Array;
    private readonly _view: DataView;

    /**
     * Create a DeprecatedAudio from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
        this._view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    }

    /**
     * Decode a deprecated-audio struct from an array.
     *
     * @param array Array to decode from.
     * @returns DeprecatedAudio instance.
     */
    public static decode(array: Uint8Array): DeprecatedAudio {
        return new DeprecatedAudio(array);
    }

    /**
     * Encode a deprecated-audio struct into an array.
     *
     * @param struct DeprecatedAudioEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<DeprecatedAudioEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        const view = new DataView(array.buffer, array.byteOffset, array.byteLength);

        // Encode `duration`
        view.setUint16(0, struct.duration, true);

        // Encode `audio-blob-id`
        utils.encodeBytes(struct.audioBlobId, array, 2);

        // Encode `audio-size`
        view.setUint32(18, struct.audioSize, true);

        // Encode `key`
        utils.encodeBytes(struct.key, array, 22);

        return array.subarray(0, 54);
    }

    /**
     * Get the amount of bytes that would be written when encoding a deprecated-audio struct into an
     * array.
     *
     * @param struct DeprecatedAudioEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<DeprecatedAudioEncodable, 'byteLength'>,
    ): types.u53 {
        return 54;
    }

    /**
     * 'duration' field accessor. See {@link DeprecatedAudioLike#duration} for the
     * field's description.
     */
    public get duration(): types.u16 {
        return this._view.getUint16(0, true);
    }

    /**
     * 'audio-blob-id' field accessor. See {@link DeprecatedAudioLike#audioBlobId} for the
     * field's description.
     */
    public get audioBlobId(): Uint8Array {
        const offset = 2;
        return this._array.subarray(offset, offset + 16);
    }

    /**
     * 'audio-size' field accessor. See {@link DeprecatedAudioLike#audioSize} for the
     * field's description.
     */
    public get audioSize(): types.u32 {
        return this._view.getUint32(18, true);
    }

    /**
     * 'key' field accessor. See {@link DeprecatedAudioLike#key} for the
     * field's description.
     */
    public get key(): Uint8Array {
        const offset = 22;
        return this._array.subarray(offset, offset + 32);
    }

    /**
     * Create a snapshot of DeprecatedAudioLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns DeprecatedAudioLike snapshot.
     */
    public snapshot(): DeprecatedAudioLike {
        return {
            duration: this.duration,
            audioBlobId: this.audioBlobId,
            audioSize: this.audioSize,
            key: this.key,
        };
    }

    /**
     * Create a clone of DeprecatedAudioLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns DeprecatedAudioLike clone.
     */
    public clone(): DeprecatedAudio {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new DeprecatedAudio(array);
    }
}

/**
 * A video message.
 *
 * Note: This message is deprecated and may be phased out eventually. When
 *       sending video, use the [`file`](ref:e2e.file) message with the
 *       rendering type `0x01` (media).
 *
 * **Flags:**
 *   - `0x01`: Send push notification.
 *
 * **Delivery receipts:** Automatic: Yes. Manual: Yes.
 *
 * **User profile distribution:** Yes.
 *
 * **Reflect:** Incoming: Yes. Outgoing: Yes.
 *
 * The video is uploaded to the blob server and encrypted by:
 *
 *     XSalsa20-Poly1305(key=<deprecated-video.key>, nonce=00..01)
 *
 * The thumbnail must be in JPEG format, is uploaded to the blob server
 * and encrypted by:
 *
 *     XSalsa20-Poly1305(key=<deprecated-video.key>, nonce=00..02)
 *
 * When receiving this message as a 1:1 conversation message:
 *
 * 1. Download thumbnail and video (if desired) data from the blob server and
 *    request the blobs to be removed.
 * 2. Add the message to the associated 1:1 conversation.
 *
 * When receiving this message as a group message (wrapped by
 * [`group-member-container`](ref:e2e.group-member-container)):
 *
 * 1. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the
 *    message has been discarded, abort these steps.
 * 2. Download thumbnail and video (if desired) data from the blob server. Do
 *    not request the blobs to be removed.
 * 3. Add the message to the associated group conversation.
 */
export interface DeprecatedVideoLike {
    /**
     * Video duration in seconds.
     */
    readonly duration: types.u16;

    /**
     * Blob ID to obtain the video data.
     */
    readonly videoBlobId: Uint8Array;

    /**
     * Video size in bytes.
     */
    readonly videoSize: types.u32;

    /**
     * Blob ID to obtain the thumbnail in JPEG format.
     */
    readonly thumbnailBlobId: Uint8Array;

    /**
     * Thumbnail size in bytes.
     */
    readonly thumbnailSize: types.u32;

    /**
     * Random symmetric key used to encrypt the video and thumbnail data.
     */
    readonly key: Uint8Array;
}

/**
 * Encodable of {@link DeprecatedVideoLike}.
 */
interface DeprecatedVideoEncodable_ {
    /**
     * 'duration' field value or encoder. See {@link DeprecatedVideoLike#duration} for
     * the field's description.
     */
    readonly duration: types.u16;

    /**
     * 'video-blob-id' field value or encoder. See {@link DeprecatedVideoLike#videoBlobId} for
     * the field's description.
     */
    readonly videoBlobId: Uint8Array | types.ByteLengthEncoder;

    /**
     * 'video-size' field value or encoder. See {@link DeprecatedVideoLike#videoSize} for
     * the field's description.
     */
    readonly videoSize: types.u32;

    /**
     * 'thumbnail-blob-id' field value or encoder. See {@link DeprecatedVideoLike#thumbnailBlobId} for
     * the field's description.
     */
    readonly thumbnailBlobId: Uint8Array | types.ByteLengthEncoder;

    /**
     * 'thumbnail-size' field value or encoder. See {@link DeprecatedVideoLike#thumbnailSize} for
     * the field's description.
     */
    readonly thumbnailSize: types.u32;

    /**
     * 'key' field value or encoder. See {@link DeprecatedVideoLike#key} for
     * the field's description.
     */
    readonly key: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for DeprecatedVideoEncodable.
 */
export type DeprecatedVideoEncodable = types.WeakOpaque<
    DeprecatedVideoEncodable_,
    {readonly DeprecatedVideoEncodable: unique symbol}
>;

/** @inheritdoc */
export class DeprecatedVideo extends base.Struct implements DeprecatedVideoLike {
    private readonly _array: Uint8Array;
    private readonly _view: DataView;

    /**
     * Create a DeprecatedVideo from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
        this._view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    }

    /**
     * Decode a deprecated-video struct from an array.
     *
     * @param array Array to decode from.
     * @returns DeprecatedVideo instance.
     */
    public static decode(array: Uint8Array): DeprecatedVideo {
        return new DeprecatedVideo(array);
    }

    /**
     * Encode a deprecated-video struct into an array.
     *
     * @param struct DeprecatedVideoEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<DeprecatedVideoEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        const view = new DataView(array.buffer, array.byteOffset, array.byteLength);

        // Encode `duration`
        view.setUint16(0, struct.duration, true);

        // Encode `video-blob-id`
        utils.encodeBytes(struct.videoBlobId, array, 2);

        // Encode `video-size`
        view.setUint32(18, struct.videoSize, true);

        // Encode `thumbnail-blob-id`
        utils.encodeBytes(struct.thumbnailBlobId, array, 22);

        // Encode `thumbnail-size`
        view.setUint32(38, struct.thumbnailSize, true);

        // Encode `key`
        utils.encodeBytes(struct.key, array, 42);

        return array.subarray(0, 74);
    }

    /**
     * Get the amount of bytes that would be written when encoding a deprecated-video struct into an
     * array.
     *
     * @param struct DeprecatedVideoEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<DeprecatedVideoEncodable, 'byteLength'>,
    ): types.u53 {
        return 74;
    }

    /**
     * 'duration' field accessor. See {@link DeprecatedVideoLike#duration} for the
     * field's description.
     */
    public get duration(): types.u16 {
        return this._view.getUint16(0, true);
    }

    /**
     * 'video-blob-id' field accessor. See {@link DeprecatedVideoLike#videoBlobId} for the
     * field's description.
     */
    public get videoBlobId(): Uint8Array {
        const offset = 2;
        return this._array.subarray(offset, offset + 16);
    }

    /**
     * 'video-size' field accessor. See {@link DeprecatedVideoLike#videoSize} for the
     * field's description.
     */
    public get videoSize(): types.u32 {
        return this._view.getUint32(18, true);
    }

    /**
     * 'thumbnail-blob-id' field accessor. See {@link DeprecatedVideoLike#thumbnailBlobId} for the
     * field's description.
     */
    public get thumbnailBlobId(): Uint8Array {
        const offset = 22;
        return this._array.subarray(offset, offset + 16);
    }

    /**
     * 'thumbnail-size' field accessor. See {@link DeprecatedVideoLike#thumbnailSize} for the
     * field's description.
     */
    public get thumbnailSize(): types.u32 {
        return this._view.getUint32(38, true);
    }

    /**
     * 'key' field accessor. See {@link DeprecatedVideoLike#key} for the
     * field's description.
     */
    public get key(): Uint8Array {
        const offset = 42;
        return this._array.subarray(offset, offset + 32);
    }

    /**
     * Create a snapshot of DeprecatedVideoLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns DeprecatedVideoLike snapshot.
     */
    public snapshot(): DeprecatedVideoLike {
        return {
            duration: this.duration,
            videoBlobId: this.videoBlobId,
            videoSize: this.videoSize,
            thumbnailBlobId: this.thumbnailBlobId,
            thumbnailSize: this.thumbnailSize,
            key: this.key,
        };
    }

    /**
     * Create a clone of DeprecatedVideoLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns DeprecatedVideoLike clone.
     */
    public clone(): DeprecatedVideo {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new DeprecatedVideo(array);
    }
}

/**
 * A file or media message.
 *
 * **Flags:**
 *   - `0x01`: Send push notification.
 *
 * **Delivery receipts:** Automatic: Yes. Manual: Yes.
 *
 * **User profile distribution:** Yes.
 *
 * **Reflect:** Incoming: Yes. Outgoing: Yes.
 *
 * The file is uploaded to the blob server and encrypted by:
 *
 *     XSalsa20-Poly1305(key=<file.key>, nonce=00..01)
 *
 * The thumbnail is uploaded to the blob server and encrypted by:
 *
 *     XSalsa20-Poly1305(key=<file.key>, nonce=00..02)
 *
 * When receiving this message as a 1:1 conversation message:
 *
 * 1. Download thumbnail and file (if desired) data from the blob server and
 *    request the blobs to be removed.
 * 2. Add the message to the associated 1:1 conversation.
 *
 * When receiving this message as a group message (wrapped by
 * [`group-member-container`](ref:e2e.group-member-container)):
 *
 * 1. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the
 *    message has been discarded, abort these steps.
 * 2. Download thumbnail and file (if desired) data from the blob server. Do
 *    not request the blobs to be removed.
 * 3. Add the message to the associated group conversation.
 */
export interface FileLike {
    /**
     * UTF-8, JSON-encoded object with the following fields:
     *
     * - Rendering type (`'j'`):
     *   - `0`: Render as a file.
     *   - `1`: Render as media (e.g. an image, audio or video).
     *   - `2`: Render as a sticker (for transparent images).
     *
     *   If this field is not set, fall back to the value of `'i'`. If no
     *   value could be determined or the rendering type is unassigned,
     *   assume `0`.
     * - Deprecated (`'i'`): Set this to the integer `1` if the rendering
     *   type is `1` or `2`, otherwise set this to the integer `0`.
     * - Encryption key (`'k'`): Random symmetric key used to encrypt the
     *   blobs (file and thumbnail data) in lowercase hex string.
     * - File blob ID (`'b'`): Blob ID in lowercase hex string
     *   representation to obtain the file data.
     * - File media type (`'m'`): The media type of the file.
     * - File name (`'n'`): Optional filename of the file.
     * - File size (`'s'`): File size in bytes.
     * - Thumbnail Blob ID (`'t'`): Optional blob containing the thumbnail
     *   file data.
     * - Thumbnail media type (`'p'`): Media type of the thumbnail.
     *   If not set, assume `image/jpeg`.
     * - Caption (`'d'`): Optional caption text.
     * - Correlation ID (`'c'`): Optional random 32 byte ASCII string to
     *   collocate multiple media files.
     * - Metadata (`'x'`): An optional metadata object as defined below.
     *
     * Metadata object fields depend on the media type of the file. All
     * fields are optional but recommended to set in order to determine the
     * layout logic while the file is being downloaded. Once the file has
     * been parsed, the parsed data supersedes this object.
     *
     * For images:
     *
     * - Width (`'w'`): The width as an integer in px.
     * - Height (`'h'`): The height as an integer in px.
     * - Animated (`'a'`): Set this to the boolean `true` if the image is
     *   animated (e.g. an animated GIF).
     *
     * For audio:
     *
     * - Duration (`'d'`): The duration as a float in seconds.
     *
     * For video:
     *
     * - Width (`'w'`): The width as an integer in px.
     * - Height (`'h'`): The height as an integer in px.
     * - Duration (`'d'`): The duration as a float in seconds.
     *
     * Note that the rendering logic depends on three key fields which
     * should be set accordingly:
     *
     * - Media type,
     * - Rendering type,
     * - Animated flag in the metadata object.
     */
    readonly file: Uint8Array;
}

/**
 * Encodable of {@link FileLike}.
 */
interface FileEncodable_ {
    /**
     * 'file' field value or encoder. See {@link FileLike#file} for
     * the field's description.
     */
    readonly file: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for FileEncodable.
 */
export type FileEncodable = types.WeakOpaque<
    FileEncodable_,
    {readonly FileEncodable: unique symbol}
>;

/** @inheritdoc */
export class File extends base.Struct implements FileLike {
    private readonly _array: Uint8Array;

    /**
     * Create a File from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a file struct from an array.
     *
     * @param array Array to decode from.
     * @returns File instance.
     */
    public static decode(array: Uint8Array): File {
        return new File(array);
    }

    /**
     * Encode a file struct into an array.
     *
     * @param struct FileEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<FileEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        let offset = 0;

        // Encode `file`
        offset += utils.encodeBytes(struct.file, array, offset);

        return array.subarray(0, offset);
    }

    /**
     * Get the amount of bytes that would be written when encoding a file struct into an
     * array.
     *
     * @param struct FileEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(struct: types.EncoderPick<FileEncodable, 'byteLength'>): types.u53 {
        let offset = 0;
        offset += utils.getByteLength(struct.file);
        return offset;
    }

    /**
     * 'file' field accessor. See {@link FileLike#file} for the
     * field's description.
     */
    public get file(): Uint8Array {
        return this._array.subarray(0);
    }

    /**
     * Create a snapshot of FileLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns FileLike snapshot.
     */
    public snapshot(): FileLike {
        return {
            file: this.file,
        };
    }

    /**
     * Create a clone of FileLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns FileLike clone.
     */
    public clone(): File {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new File(array);
    }
}

/**
 * Creates a new poll or finalises an existing poll.
 *
 * During the lifecycle of a poll, this message will be used exactly twice:
 * Once to create the poll, and once to close it.
 *
 * **Flags**:
 *   - `0x01`: Send push notification.
 *
 * **Delivery receipts:** Automatic: Yes. Manual: Yes.
 *
 * **User profile distribution:** Yes.
 *
 * **Reflect:** Incoming: Yes. Outgoing: Yes.
 *
 * When receiving this message as a 1:1 conversation message:
 *
 * 1. Run the _Common Poll Setup Receive Steps_.
 *
 * When receiving this message as a group message (wrapped by
 * [`group-member-container`](ref:e2e.group-member-container)):
 *
 * 1. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the
 *    message has been discarded, abort these steps.
 * 2. Run the _Common Poll Setup Receive Steps_.
 *
 * The following steps are defined as the _Common Poll Setup Receive Steps_.
 *
 * 1. Let `state` be the _State_ field of the message. Let `participants` be
 *    the _Participants_ field of the message.
 * 2. Look up the poll with the given ID within the conversation.
 * 3. If no associated poll could be found:
 *     1. If `state` is `1` (closed), discard the message and abort these steps.
 *     2. Add the poll to the associated conversation with the provided
 *        fields of the message and abort these steps.
 * 4. If the associated poll is closed, discard the message and abort these steps.
 * 5. If `state` is `0` (open), discard the message and abort these steps.
 * 6. Close the poll with the given `participants`, ignore any other fields
 *    of the message.
 */
export interface PollSetupLike {
    /**
     * Random unique (per creator within this conversation) ID of the poll.
     */
    readonly id: types.u64;

    /**
     * UTF-8, JSON-encoded object with the following fields:
     *
     * - Description (`'d'`): A short description/topic string for the poll.
     * - State (`'s'`):
     *   - `0`: Poll is _open_ for votes.
     *   - `1`: Poll has been _closed_.
     *
     *   A state transition from _closed_ to _open_ is illegal and must be
     *   ignored by the receiving client.
     * - Answer type (`'a'`):
     *   - `0`: Single choice poll.
     *   - `1`: Multiple choice poll.
     *
     *   Any transition from one of the types to another is illegal and
     *   must be ignored by the receiving client.
     * - Announce type (`'t'`):
     *   - `0`: Announce votes in form of the `poll-vote` message
     *     only to the creator of the ballot. Results are invisible until
     *     the creator closes the vote and reports the final results.
     *   - `1`: Announce votes in form of the `poll-vote` message to
     *     everyone in the conversation. Interim results are therefore
     *     visible to everyone.
     *
     *   Any transition from one of the types to another is illegal and
     *   must be ignored by the receiving client.
     * - Display mode (`'u'`):
     *   - `0`: List mode. List choices of all participants as presented
     *     by this message.
     *   - `1`: Summary mode. Only display the total amount of votes per
     *     choice and the user's vote (if any).
     *
     *   If the field is not present, assume _list_ mode (`0`). Any
     *   transition from one of the modes to another is illegal and must be
     *   ignored by the receiving client.
     * - Choices type (`'o'`, DEPRECATED): Always set this to the integer `0`.
     * - Participants (`'p'`): A list of Threema IDs that participated in
     *   the poll (i.e. they cast a vote). This field must only be
     *   present if the poll is being _closed_. In display mode _summary_,
     *   this field should be an empty list and must be ignored by the
     *   receiver.
     * - Choices (`'c'`): A list of choice objects as defined below.
     *
     * Choice object fields:
     *
     * - Choice ID (`'i'`): A per-poll unique ID of the choice in form of
     *   an integer. Used when casting a vote.
     * - Description (`'n'`): Choice description in form of a string.
     * - Sort key (`'o'`, DEPRECATED): Set this to the index of the choice
     *   object within the _choices_ list.
     * - Participant votes (`'r'`): A list of indices referring to the
     *   index of the participant (as defined in the _participants_ list)
     *   that cast a vote for this choice. This field must only be present
     *   if the poll is being _closed_. In display mode _summary_ this
     *   should be an empty list and must be ignored by the receiver.
     * - Total amount of votes (`'t'`): The total amount of votes for this
     *   choice. This field must only be present if the poll is being
     *   _closed_. In display mode _normal_ this field should not be
     *   present and must be ignored by the receiver.
     */
    readonly poll: Uint8Array;
}

/**
 * Encodable of {@link PollSetupLike}.
 */
interface PollSetupEncodable_ {
    /**
     * 'id' field value or encoder. See {@link PollSetupLike#id} for
     * the field's description.
     */
    readonly id: types.u64;

    /**
     * 'poll' field value or encoder. See {@link PollSetupLike#poll} for
     * the field's description.
     */
    readonly poll: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for PollSetupEncodable.
 */
export type PollSetupEncodable = types.WeakOpaque<
    PollSetupEncodable_,
    {readonly PollSetupEncodable: unique symbol}
>;

/** @inheritdoc */
export class PollSetup extends base.Struct implements PollSetupLike {
    private readonly _array: Uint8Array;
    private readonly _view: DataView;

    /**
     * Create a PollSetup from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
        this._view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    }

    /**
     * Decode a poll-setup struct from an array.
     *
     * @param array Array to decode from.
     * @returns PollSetup instance.
     */
    public static decode(array: Uint8Array): PollSetup {
        return new PollSetup(array);
    }

    /**
     * Encode a poll-setup struct into an array.
     *
     * @param struct PollSetupEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<PollSetupEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        const view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        let offset = 8;

        // Encode `id`
        view.setBigUint64(0, struct.id, true);

        // Encode `poll`
        offset += utils.encodeBytes(struct.poll, array, offset);

        return array.subarray(0, offset);
    }

    /**
     * Get the amount of bytes that would be written when encoding a poll-setup struct into an
     * array.
     *
     * @param struct PollSetupEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<PollSetupEncodable, 'byteLength'>,
    ): types.u53 {
        let offset = 8;
        offset += utils.getByteLength(struct.poll);
        return offset;
    }

    /**
     * 'id' field accessor. See {@link PollSetupLike#id} for the
     * field's description.
     */
    public get id(): types.u64 {
        return this._view.getBigUint64(0, true);
    }

    /**
     * 'poll' field accessor. See {@link PollSetupLike#poll} for the
     * field's description.
     */
    public get poll(): Uint8Array {
        return this._array.subarray(8);
    }

    /**
     * Create a snapshot of PollSetupLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns PollSetupLike snapshot.
     */
    public snapshot(): PollSetupLike {
        return {
            id: this.id,
            poll: this.poll,
        };
    }

    /**
     * Create a clone of PollSetupLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns PollSetupLike clone.
     */
    public clone(): PollSetup {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new PollSetup(array);
    }
}

/**
 * Cast a vote on a poll.
 *
 * **Flags:** None.
 *
 * **Delivery receipts:** Automatic: No. Manual: No.
 *
 * **User profile distribution:** Yes.
 *
 * **Reflect:** Incoming: Yes. Outgoing: Yes.
 *
 * When receiving this message as a 1:1 conversation message:
 *
 * 1. Run the _Common Poll Vote Receive Steps_.
 *
 * When receiving this message as a group message (wrapped by
 * [`group-member-container`](ref:e2e.group-member-container)):
 *
 * 1. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the
 *    message has been discarded, abort these steps.
 * 2. Run the _Common Poll Vote Receive Steps_.
 *
 * The following steps are defined as the _Common Poll Vote Receive Steps_.
 *
 * 1. Look up the poll with the given ID within the conversation.
 * 2. If no associated poll could be found or if the associated poll is
 *    closed, discard the message and abort these steps.
 * 3. Update the poll with the provided choices of the sender.
 */
export interface PollVoteLike {
    /**
     * ID of the associated poll.
     */
    readonly pollId: types.u64;

    /**
     * The Threema ID of the creator of the poll.
     */
    readonly creatorIdentity: Uint8Array;

    /**
     * UTF-8, JSON-encoded list containing one or more choice tuples. Each
     * choice tuple contains the following two integer values:
     *
     * - Choice ID, referring to the Choice ID defined in the
     *   `poll-setup` message.
     * - Selected:
     *   - `0`: The choice has not been selected.
     *   - `1`: The choice has been selected.
     *
     * Note: For protocol simplicity, a vote must always include all possible
     * choices, whether or not they have been selected.
     */
    readonly choices: Uint8Array;
}

/**
 * Encodable of {@link PollVoteLike}.
 */
interface PollVoteEncodable_ {
    /**
     * 'poll-id' field value or encoder. See {@link PollVoteLike#pollId} for
     * the field's description.
     */
    readonly pollId: types.u64;

    /**
     * 'creator-identity' field value or encoder. See {@link PollVoteLike#creatorIdentity} for
     * the field's description.
     */
    readonly creatorIdentity: Uint8Array | types.ByteLengthEncoder;

    /**
     * 'choices' field value or encoder. See {@link PollVoteLike#choices} for
     * the field's description.
     */
    readonly choices: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for PollVoteEncodable.
 */
export type PollVoteEncodable = types.WeakOpaque<
    PollVoteEncodable_,
    {readonly PollVoteEncodable: unique symbol}
>;

/** @inheritdoc */
export class PollVote extends base.Struct implements PollVoteLike {
    private readonly _array: Uint8Array;
    private readonly _view: DataView;

    /**
     * Create a PollVote from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
        this._view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    }

    /**
     * Decode a poll-vote struct from an array.
     *
     * @param array Array to decode from.
     * @returns PollVote instance.
     */
    public static decode(array: Uint8Array): PollVote {
        return new PollVote(array);
    }

    /**
     * Encode a poll-vote struct into an array.
     *
     * @param struct PollVoteEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<PollVoteEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        const view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        let offset = 16;

        // Encode `poll-id`
        view.setBigUint64(0, struct.pollId, true);

        // Encode `creator-identity`
        utils.encodeBytes(struct.creatorIdentity, array, 8);

        // Encode `choices`
        offset += utils.encodeBytes(struct.choices, array, offset);

        return array.subarray(0, offset);
    }

    /**
     * Get the amount of bytes that would be written when encoding a poll-vote struct into an
     * array.
     *
     * @param struct PollVoteEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<PollVoteEncodable, 'byteLength'>,
    ): types.u53 {
        let offset = 16;
        offset += utils.getByteLength(struct.choices);
        return offset;
    }

    /**
     * 'poll-id' field accessor. See {@link PollVoteLike#pollId} for the
     * field's description.
     */
    public get pollId(): types.u64 {
        return this._view.getBigUint64(0, true);
    }

    /**
     * 'creator-identity' field accessor. See {@link PollVoteLike#creatorIdentity} for the
     * field's description.
     */
    public get creatorIdentity(): Uint8Array {
        const offset = 8;
        return this._array.subarray(offset, offset + 8);
    }

    /**
     * 'choices' field accessor. See {@link PollVoteLike#choices} for the
     * field's description.
     */
    public get choices(): Uint8Array {
        return this._array.subarray(16);
    }

    /**
     * Create a snapshot of PollVoteLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns PollVoteLike snapshot.
     */
    public snapshot(): PollVoteLike {
        return {
            pollId: this.pollId,
            creatorIdentity: this.creatorIdentity,
            choices: this.choices,
        };
    }

    /**
     * Create a clone of PollVoteLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns PollVoteLike clone.
     */
    public clone(): PollVote {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new PollVote(array);
    }
}

/**
 * Initiates a call.
 *
 * **Flags:**
 *   - `0x01`: Send push notification.
 *   - `0x20`: Short-lived server queuing.
 *
 * **Delivery receipts:** Automatic: No. Manual: No.
 *
 * **User profile distribution:** Yes.
 *
 * **Reflect:** Incoming: Yes. Outgoing: Yes.
 *
 * [//]: # "When sending: TODO(SE-102)"
 * [//]: # "When receiving: TODO(SE-102)"
 */
export interface CallOfferLike {
    /**
     * UTF-8, JSON-encoded object with the following fields:
     *
     * - Call ID (`'callId'`): Random 32 bit unsigned integer greater than 0
     *   that uniquely identifies a call throughout its lifetime. Assume
     *   `0` if not set.
     * - WebRTC Offer (`'offer'`): An offer object.
     * - Feature negotiation (`'features'`): Optional Call Features object.
     *
     * Offer object fields:
     *
     * - WebRTC Offer SDP type (`'sdpType'`): Set this to `'offer'` and ignore
     *   offers with other types.
     * - WebRTC Offer SDP (`'sdp'`): Opaque string containing the SDP.
     */
    readonly offer: Uint8Array;
}

/**
 * Encodable of {@link CallOfferLike}.
 */
interface CallOfferEncodable_ {
    /**
     * 'offer' field value or encoder. See {@link CallOfferLike#offer} for
     * the field's description.
     */
    readonly offer: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for CallOfferEncodable.
 */
export type CallOfferEncodable = types.WeakOpaque<
    CallOfferEncodable_,
    {readonly CallOfferEncodable: unique symbol}
>;

/** @inheritdoc */
export class CallOffer extends base.Struct implements CallOfferLike {
    private readonly _array: Uint8Array;

    /**
     * Create a CallOffer from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a call-offer struct from an array.
     *
     * @param array Array to decode from.
     * @returns CallOffer instance.
     */
    public static decode(array: Uint8Array): CallOffer {
        return new CallOffer(array);
    }

    /**
     * Encode a call-offer struct into an array.
     *
     * @param struct CallOfferEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<CallOfferEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        let offset = 0;

        // Encode `offer`
        offset += utils.encodeBytes(struct.offer, array, offset);

        return array.subarray(0, offset);
    }

    /**
     * Get the amount of bytes that would be written when encoding a call-offer struct into an
     * array.
     *
     * @param struct CallOfferEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<CallOfferEncodable, 'byteLength'>,
    ): types.u53 {
        let offset = 0;
        offset += utils.getByteLength(struct.offer);
        return offset;
    }

    /**
     * 'offer' field accessor. See {@link CallOfferLike#offer} for the
     * field's description.
     */
    public get offer(): Uint8Array {
        return this._array.subarray(0);
    }

    /**
     * Create a snapshot of CallOfferLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns CallOfferLike snapshot.
     */
    public snapshot(): CallOfferLike {
        return {
            offer: this.offer,
        };
    }

    /**
     * Create a clone of CallOfferLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns CallOfferLike clone.
     */
    public clone(): CallOffer {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new CallOffer(array);
    }
}

/**
 * Answer or reject a call.
 *
 * **Flags:**
 *   - `0x01`: Send push notification.
 *   - `0x20`: Short-lived server queuing.
 *
 * **Delivery receipts:** Automatic: No. Manual: No.
 *
 * **User profile distribution:** Only if accepting (action=1).
 *
 * **Reflect:** Incoming: Yes. Outgoing: Yes.
 *
 * [//]: # "When sending: TODO(SE-102)"
 * [//]: # "When receiving: TODO(SE-102)"
 */
export interface CallAnswerLike {
    /**
     * UTF-8, JSON-encoded object with the following fields:
     *
     * - Call ID (`'callId'`): Random 32 bit unsigned integer greater than 0
     *   that uniquely identifies a call throughout its lifetime. Assume
     *   `0` if not set.
     * - Required action (`'action'`):
     *   - `0`: The call has been rejected and needs to be aborted.
     *   - `1`: The call has been accepted and a connection needs to be
     *     established.
     * - Rejection reason (`'rejectReason'`): If the call has been rejected,
     *   this field contains a reject reason:
     *   - `0`: Generic or unspecified rejection.
     *   - `1`: The callee is busy (another call is active).
     *   - `2`: The callee did not accept the call in time.
     *   - `3`: The callee explicitly rejected the call.
     *   - `4`: The callee disabled calls.
     *   - `5`: The callee was called during an off-hour period.
     * - WebRTC Answer (`'answer'`): An answer object.
     * - Feature negotiation (`'features'`): Optional Call Features object.
     *
     * Answer object fields:
     *
     * - WebRTC Answer SDP type (`'sdpType'`): Set this to `'answer'` and ignore
     *   answers with other types.
     * - WebRTC Answer SDP (`'sdp'`): Opaque string containing the SDP.
     */
    readonly answer: Uint8Array;
}

/**
 * Encodable of {@link CallAnswerLike}.
 */
interface CallAnswerEncodable_ {
    /**
     * 'answer' field value or encoder. See {@link CallAnswerLike#answer} for
     * the field's description.
     */
    readonly answer: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for CallAnswerEncodable.
 */
export type CallAnswerEncodable = types.WeakOpaque<
    CallAnswerEncodable_,
    {readonly CallAnswerEncodable: unique symbol}
>;

/** @inheritdoc */
export class CallAnswer extends base.Struct implements CallAnswerLike {
    private readonly _array: Uint8Array;

    /**
     * Create a CallAnswer from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a call-answer struct from an array.
     *
     * @param array Array to decode from.
     * @returns CallAnswer instance.
     */
    public static decode(array: Uint8Array): CallAnswer {
        return new CallAnswer(array);
    }

    /**
     * Encode a call-answer struct into an array.
     *
     * @param struct CallAnswerEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<CallAnswerEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        let offset = 0;

        // Encode `answer`
        offset += utils.encodeBytes(struct.answer, array, offset);

        return array.subarray(0, offset);
    }

    /**
     * Get the amount of bytes that would be written when encoding a call-answer struct into an
     * array.
     *
     * @param struct CallAnswerEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<CallAnswerEncodable, 'byteLength'>,
    ): types.u53 {
        let offset = 0;
        offset += utils.getByteLength(struct.answer);
        return offset;
    }

    /**
     * 'answer' field accessor. See {@link CallAnswerLike#answer} for the
     * field's description.
     */
    public get answer(): Uint8Array {
        return this._array.subarray(0);
    }

    /**
     * Create a snapshot of CallAnswerLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns CallAnswerLike snapshot.
     */
    public snapshot(): CallAnswerLike {
        return {
            answer: this.answer,
        };
    }

    /**
     * Create a clone of CallAnswerLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns CallAnswerLike clone.
     */
    public clone(): CallAnswer {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new CallAnswer(array);
    }
}

/**
 * An ICE candidate for an ongoing call.
 *
 * **Flags:**
 *   - `0x01`: Send push notification.
 *   - `0x20`: Short-lived server queuing.
 *
 * **Delivery receipts:** Automatic: No. Manual: No.
 *
 * **User profile distribution:** No.
 *
 * **Reflect:** Incoming: Yes. Outgoing: No.
 */
export interface CallIceCandidateLike {
    /**
     * UTF-8, JSON-encoded object with the following fields:
     *
     * - Call ID (`'callId'`): Random 32 bit unsigned integer greater than 0
     *   that uniquely identifies a call throughout its lifetime. Assume
     *   `0` if not set.
     * - Deprecated (`'removed'`): Always set this to `false` and ignore
     *   messages with this field set to `true`.
     * - WebRTC Candidates (`'candidates'`): An array of candidate objects.
     *
     * Candidate object fields:
     * - WebRTC Candidate SDP (`'candidate'`): Opaque string containing the
     *   ICE candidate SDP.
     * - WebRTC MID (`'sdpMid'`): Media stream identification string or
     *   `null`.
     * - WebRTC Media Line Index (`'sdpMLineIndex'`): Media description
     *   line index integer or `null`.
     * - WebRTC Username Fragment (`'ufrag'`): ICE username fragment or
     *   `null`.
     */
    readonly candidates: Uint8Array;
}

/**
 * Encodable of {@link CallIceCandidateLike}.
 */
interface CallIceCandidateEncodable_ {
    /**
     * 'candidates' field value or encoder. See {@link CallIceCandidateLike#candidates} for
     * the field's description.
     */
    readonly candidates: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for CallIceCandidateEncodable.
 */
export type CallIceCandidateEncodable = types.WeakOpaque<
    CallIceCandidateEncodable_,
    {readonly CallIceCandidateEncodable: unique symbol}
>;

/** @inheritdoc */
export class CallIceCandidate extends base.Struct implements CallIceCandidateLike {
    private readonly _array: Uint8Array;

    /**
     * Create a CallIceCandidate from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a call-ice-candidate struct from an array.
     *
     * @param array Array to decode from.
     * @returns CallIceCandidate instance.
     */
    public static decode(array: Uint8Array): CallIceCandidate {
        return new CallIceCandidate(array);
    }

    /**
     * Encode a call-ice-candidate struct into an array.
     *
     * @param struct CallIceCandidateEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<CallIceCandidateEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        let offset = 0;

        // Encode `candidates`
        offset += utils.encodeBytes(struct.candidates, array, offset);

        return array.subarray(0, offset);
    }

    /**
     * Get the amount of bytes that would be written when encoding a call-ice-candidate struct into an
     * array.
     *
     * @param struct CallIceCandidateEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<CallIceCandidateEncodable, 'byteLength'>,
    ): types.u53 {
        let offset = 0;
        offset += utils.getByteLength(struct.candidates);
        return offset;
    }

    /**
     * 'candidates' field accessor. See {@link CallIceCandidateLike#candidates} for the
     * field's description.
     */
    public get candidates(): Uint8Array {
        return this._array.subarray(0);
    }

    /**
     * Create a snapshot of CallIceCandidateLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns CallIceCandidateLike snapshot.
     */
    public snapshot(): CallIceCandidateLike {
        return {
            candidates: this.candidates,
        };
    }

    /**
     * Create a clone of CallIceCandidateLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns CallIceCandidateLike clone.
     */
    public clone(): CallIceCandidate {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new CallIceCandidate(array);
    }
}

/**
 * Hang up a call.
 *
 * **Flags:**
 *   - `0x01`: Send push notification.
 *
 * **Delivery receipts:** Automatic: No. Manual: No.
 *
 * **User profile distribution:** No.
 *
 * **Reflect:** Incoming: Yes. Outgoing: Yes.
 *
 * [//]: # "When sending: TODO(SE-102)"
 * [//]: # "When receiving: TODO(SE-102)"
 */
export interface CallHangupLike {
    /**
     * UTF-8, JSON-encoded object. If this field contains zero bytes, assume
     * an empty object. Contains the following fields:
     *
     * - Call ID (`'callId'`): Random 32 bit unsigned integer greater than 0
     *   that uniquely identifies a call throughout its lifetime. Assume
     *   `0` if not set.
     */
    readonly hangup: Uint8Array;
}

/**
 * Encodable of {@link CallHangupLike}.
 */
interface CallHangupEncodable_ {
    /**
     * 'hangup' field value or encoder. See {@link CallHangupLike#hangup} for
     * the field's description.
     */
    readonly hangup: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for CallHangupEncodable.
 */
export type CallHangupEncodable = types.WeakOpaque<
    CallHangupEncodable_,
    {readonly CallHangupEncodable: unique symbol}
>;

/** @inheritdoc */
export class CallHangup extends base.Struct implements CallHangupLike {
    private readonly _array: Uint8Array;

    /**
     * Create a CallHangup from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a call-hangup struct from an array.
     *
     * @param array Array to decode from.
     * @returns CallHangup instance.
     */
    public static decode(array: Uint8Array): CallHangup {
        return new CallHangup(array);
    }

    /**
     * Encode a call-hangup struct into an array.
     *
     * @param struct CallHangupEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<CallHangupEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        let offset = 0;

        // Encode `hangup`
        offset += utils.encodeBytes(struct.hangup, array, offset);

        return array.subarray(0, offset);
    }

    /**
     * Get the amount of bytes that would be written when encoding a call-hangup struct into an
     * array.
     *
     * @param struct CallHangupEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<CallHangupEncodable, 'byteLength'>,
    ): types.u53 {
        let offset = 0;
        offset += utils.getByteLength(struct.hangup);
        return offset;
    }

    /**
     * 'hangup' field accessor. See {@link CallHangupLike#hangup} for the
     * field's description.
     */
    public get hangup(): Uint8Array {
        return this._array.subarray(0);
    }

    /**
     * Create a snapshot of CallHangupLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns CallHangupLike snapshot.
     */
    public snapshot(): CallHangupLike {
        return {
            hangup: this.hangup,
        };
    }

    /**
     * Create a clone of CallHangupLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns CallHangupLike clone.
     */
    public clone(): CallHangup {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new CallHangup(array);
    }
}

/**
 * Sent by the callee to indicate that the call is ringing.
 *
 * **Flags:**
 *   - `0x01`: Send push notification.
 *   - `0x20`: Short-lived server queuing.
 *
 * **Delivery receipts:** Automatic: No. Manual: No.
 *
 * **User profile distribution:** No.
 *
 * **Reflect:** Incoming: Yes. Outgoing: Yes.
 *
 * [//]: # "When sending: TODO(SE-102)"
 * [//]: # "When receiving: TODO(SE-102)"
 */
export interface CallRingingLike {
    /**
     * UTF-8, JSON-encoded object. If this field contains zero bytes, assume
     * an empty object. Contains the following fields:
     *
     * - Call ID (`'callId'`): Random 32 bit unsigned integer greater than 0
     *   that uniquely identifies a call throughout its lifetime. Assume
     *   `0` if not set.
     */
    readonly hangup: Uint8Array;
}

/**
 * Encodable of {@link CallRingingLike}.
 */
interface CallRingingEncodable_ {
    /**
     * 'hangup' field value or encoder. See {@link CallRingingLike#hangup} for
     * the field's description.
     */
    readonly hangup: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for CallRingingEncodable.
 */
export type CallRingingEncodable = types.WeakOpaque<
    CallRingingEncodable_,
    {readonly CallRingingEncodable: unique symbol}
>;

/** @inheritdoc */
export class CallRinging extends base.Struct implements CallRingingLike {
    private readonly _array: Uint8Array;

    /**
     * Create a CallRinging from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a call-ringing struct from an array.
     *
     * @param array Array to decode from.
     * @returns CallRinging instance.
     */
    public static decode(array: Uint8Array): CallRinging {
        return new CallRinging(array);
    }

    /**
     * Encode a call-ringing struct into an array.
     *
     * @param struct CallRingingEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<CallRingingEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        let offset = 0;

        // Encode `hangup`
        offset += utils.encodeBytes(struct.hangup, array, offset);

        return array.subarray(0, offset);
    }

    /**
     * Get the amount of bytes that would be written when encoding a call-ringing struct into an
     * array.
     *
     * @param struct CallRingingEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<CallRingingEncodable, 'byteLength'>,
    ): types.u53 {
        let offset = 0;
        offset += utils.getByteLength(struct.hangup);
        return offset;
    }

    /**
     * 'hangup' field accessor. See {@link CallRingingLike#hangup} for the
     * field's description.
     */
    public get hangup(): Uint8Array {
        return this._array.subarray(0);
    }

    /**
     * Create a snapshot of CallRingingLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns CallRingingLike snapshot.
     */
    public snapshot(): CallRingingLike {
        return {
            hangup: this.hangup,
        };
    }

    /**
     * Create a clone of CallRingingLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns CallRingingLike clone.
     */
    public clone(): CallRinging {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new CallRinging(array);
    }
}

/**
 * Confirms reception or delivers detailed status updates of a message.
 *
 * **Flags:** None.
 *
 * **Delivery receipts:** No, that would be silly!
 *
 * **User profile distribution:** Only for reactions.
 *
 * **Reflect:** Incoming: Yes. Outgoing: Yes.
 *
 * Note: When outgoing delivery receipts are turned off, reflect an
 * `IncomingMessageUpdate` instead.
 *
 * When receiving this message as a 1:1 conversation status update message:
 *
 * 1. For each message id of `message-ids`, look up the associated message
 *    in the conversation and let `messages` be the result. Ignore message
 *    ids where an associated message could not be found.
 * 2. For each `message` of `messages`, apply and replace the status or
 *    reaction of the sender to `message` by following the replacement logic
 *    outlied in the `status` field.
 *
 * When receiving this message as a group status update message (wrapped by
 * [`group-member-container`](ref:e2e.group-member-container):
 *
 * 1. If `status` is not `0x03` or `0x04`, discard the message and abort
 *    these steps.
 * 2. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the
 *    message has been discarded, abort these steps.
 * 3. For each message id of `message-ids`, look up the associated message
 *    in the group conversation and let `messages` be the result. Ignore
 *    message ids where an associated message could not be found.
 * 4. For each `message` of `messages`, apply and replace the reaction of the
 *    sender to `message`.
 */
export interface DeliveryReceiptLike {
    /**
     * Message status:
     *
     * - `0x01`: Message was received.
     * - `0x02`: Message was read.
     * - `0x03`: Message has been explicitly acknowledged.
     * - `0x04`: Message has been explicitly declined.
     *
     * The following replacement logic is to be applied on a message's
     * status when displayed:
     *
     * 1. `0x03` or `0x04` replace each other and groups listed below,
     * 2. `0x02` replaces groups listed below,
     * 3. `0x01` replaces the unlisted _created_ status.
     */
    readonly status: types.u8;

    /**
     * One or more `message-id`s whose status should be updated.
     */
    readonly messageIds: Iterable<types.u64>;
}

/**
 * Encodable of {@link DeliveryReceiptLike}.
 */
interface DeliveryReceiptEncodable_ {
    /**
     * 'status' field value or encoder. See {@link DeliveryReceiptLike#status} for
     * the field's description.
     */
    readonly status: types.u8;

    /**
     * 'message-ids' field value or encoder. See {@link DeliveryReceiptLike#messageIds} for
     * the field's description.
     */
    readonly messageIds: types.BoundedIterable<types.u64>;
}

/**
 * New-type for DeliveryReceiptEncodable.
 */
export type DeliveryReceiptEncodable = types.WeakOpaque<
    DeliveryReceiptEncodable_,
    {readonly DeliveryReceiptEncodable: unique symbol}
>;

/** @inheritdoc */
export class DeliveryReceipt extends base.Struct implements DeliveryReceiptLike {
    private readonly _array: Uint8Array;
    private readonly _view: DataView;

    /**
     * Create a DeliveryReceipt from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
        this._view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    }

    /**
     * Decode a delivery-receipt struct from an array.
     *
     * @param array Array to decode from.
     * @returns DeliveryReceipt instance.
     */
    public static decode(array: Uint8Array): DeliveryReceipt {
        return new DeliveryReceipt(array);
    }

    /**
     * Encode a delivery-receipt struct into an array.
     *
     * @param struct DeliveryReceiptEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<DeliveryReceiptEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        const view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        let offset = 1;

        // Encode `status`
        array[0] = struct.status;

        // Encode `message-ids`
        offset += utils.encodeIterable(struct.messageIds, offset, 8, (o, v) => {
            view.setBigUint64(o, v, true);
        });

        return array.subarray(0, offset);
    }

    /**
     * Get the amount of bytes that would be written when encoding a delivery-receipt struct into an
     * array.
     *
     * @param struct DeliveryReceiptEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<DeliveryReceiptEncodable, 'byteLength'>,
    ): types.u53 {
        let offset = 1;
        offset += struct.messageIds.length * 8;
        return offset;
    }

    /**
     * 'status' field accessor. See {@link DeliveryReceiptLike#status} for the
     * field's description.
     */
    public get status(): types.u8 {
        return this._array[0];
    }

    /**
     * 'message-ids' field accessor. See {@link DeliveryReceiptLike#messageIds} for the
     * field's description.
     */
    public get messageIds(): Iterable<types.u64> {
        return utils.decodeIterable(this._view, 1, 8, (o) => this._view.getBigUint64(o, true));
    }

    /**
     * Create a snapshot of DeliveryReceiptLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns DeliveryReceiptLike snapshot.
     */
    public snapshot(): DeliveryReceiptLike {
        return {
            status: this.status,
            messageIds: this.messageIds,
        };
    }

    /**
     * Create a clone of DeliveryReceiptLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns DeliveryReceiptLike clone.
     */
    public clone(): DeliveryReceipt {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new DeliveryReceipt(array);
    }
}

/**
 * Indicates whether a contact is currently typing.
 *
 * **Flags:**
 *   - `0x02`: No server queuing.
 *   - `0x04`: No server acknowledgement.
 *
 * **Delivery receipts:** Automatic: No. Manual: No.
 *
 * **User profile distribution:** No.
 *
 * **Reflect:** Incoming: Yes, with ephemeral marker. Outgoing: No.
 *
 * When the user is currently typing in the compose area of an associated
 * conversation:
 *
 * 1. Send this message with `is-typing` set to `1`.
 * 2. Start a _user is typing_ timer in the conversation to rerun these
 *    steps in 10s.
 *
 * When the user stopped typing in the compose area of an associated
 * conversation (or left the conversation view):
 *
 * 1. If no _user is typing_ timer is running for the conversation, abort
 *    these steps.
 * 2. Stop the _user is typing_ timer of the conversation.
 * 3. Send this message with `is-typing` set to `0`.
 *
 * When receiving this message:
 *
 * 1. If the sender is blocked, discard the message and abort these steps.
 * 2. If `is-typing` is `1`, start a timer to display that the sender is
 *    typing in the associated conversation for the next 15s.
 * 3. If `is-typing` is `0`, cancel any running timer displaying that the
 *    sender is typing in the associated conversation.
 */
export interface TypingIndicatorLike {
    /**
     * Set to `1` in case the contact is currently typing or `0` in
     * case the contact stopped typing. Other values are invalid.
     */
    readonly isTyping: types.u8;
}

/**
 * Encodable of {@link TypingIndicatorLike}.
 */
interface TypingIndicatorEncodable_ {
    /**
     * 'is-typing' field value or encoder. See {@link TypingIndicatorLike#isTyping} for
     * the field's description.
     */
    readonly isTyping: types.u8;
}

/**
 * New-type for TypingIndicatorEncodable.
 */
export type TypingIndicatorEncodable = types.WeakOpaque<
    TypingIndicatorEncodable_,
    {readonly TypingIndicatorEncodable: unique symbol}
>;

/** @inheritdoc */
export class TypingIndicator extends base.Struct implements TypingIndicatorLike {
    private readonly _array: Uint8Array;

    /**
     * Create a TypingIndicator from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a typing-indicator struct from an array.
     *
     * @param array Array to decode from.
     * @returns TypingIndicator instance.
     */
    public static decode(array: Uint8Array): TypingIndicator {
        return new TypingIndicator(array);
    }

    /**
     * Encode a typing-indicator struct into an array.
     *
     * @param struct TypingIndicatorEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<TypingIndicatorEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        // Encode `is-typing`
        array[0] = struct.isTyping;

        return array.subarray(0, 1);
    }

    /**
     * Get the amount of bytes that would be written when encoding a typing-indicator struct into an
     * array.
     *
     * @param struct TypingIndicatorEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<TypingIndicatorEncodable, 'byteLength'>,
    ): types.u53 {
        return 1;
    }

    /**
     * 'is-typing' field accessor. See {@link TypingIndicatorLike#isTyping} for the
     * field's description.
     */
    public get isTyping(): types.u8 {
        return this._array[0];
    }

    /**
     * Create a snapshot of TypingIndicatorLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns TypingIndicatorLike snapshot.
     */
    public snapshot(): TypingIndicatorLike {
        return {
            isTyping: this.isTyping,
        };
    }

    /**
     * Create a clone of TypingIndicatorLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns TypingIndicatorLike clone.
     */
    public clone(): TypingIndicator {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new TypingIndicator(array);
    }
}

/**
 * Set the profile picture of a contact or a group.
 *
 * **Flags:** None.
 *
 * **Delivery receipts:** Automatic: No. Manual: No.
 *
 * **User profile distribution:** No.
 *
 * **Reflect (contacts):** Incoming: No. Outgoing: No.
 *
 * **Reflect (groups):** Incoming: Yes. Outgoing: Yes.
 *
 * The profile picture must be in JPEG format, is uploaded to the blob
 * server and encrypted by:
 *
 *     XSalsa20-Poly1305(key=<set-profile-picture.key>, nonce=00..01)
 *
 * When reflected from another device as an outgoing contact control message:
 *
 * 1. Store the enclosed blob ID as the most recently used blob ID for that
 *    contact.
 *
 * When receiving this message as a contact control message:
 *
 * 1. Download the picture from the blob server but do not request the blob
 *    to be removed. Store the profile picture.
 * 2. Store the picture as the _contact-defined_ profile picture and run the
 *    _Contact Profile Picture Selection Steps_.
 *
 * When receiving this message as a group control message (wrapped by
 * [`group-creator-container`](ref:e2e.group-creator-container)):
 *
 * 1. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the
 *    message has been discarded, abort these steps.
 * 2. Download the picture from the blob server but do not request the blob
 *    to be removed.
 * 3. Store the profile picture and and apply it to the group.
 */
export interface SetProfilePictureLike {
    /**
     * Blob ID to obtain the image data.
     */
    readonly pictureBlobId: Uint8Array;

    /**
     * Profile picture size in bytes.
     */
    readonly pictureSize: types.u32;

    /**
     * Random symmetric key used to encrypt the image data.
     */
    readonly key: Uint8Array;
}

/**
 * Encodable of {@link SetProfilePictureLike}.
 */
interface SetProfilePictureEncodable_ {
    /**
     * 'picture-blob-id' field value or encoder. See {@link SetProfilePictureLike#pictureBlobId} for
     * the field's description.
     */
    readonly pictureBlobId: Uint8Array | types.ByteLengthEncoder;

    /**
     * 'picture-size' field value or encoder. See {@link SetProfilePictureLike#pictureSize} for
     * the field's description.
     */
    readonly pictureSize: types.u32;

    /**
     * 'key' field value or encoder. See {@link SetProfilePictureLike#key} for
     * the field's description.
     */
    readonly key: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for SetProfilePictureEncodable.
 */
export type SetProfilePictureEncodable = types.WeakOpaque<
    SetProfilePictureEncodable_,
    {readonly SetProfilePictureEncodable: unique symbol}
>;

/** @inheritdoc */
export class SetProfilePicture extends base.Struct implements SetProfilePictureLike {
    private readonly _array: Uint8Array;
    private readonly _view: DataView;

    /**
     * Create a SetProfilePicture from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
        this._view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    }

    /**
     * Decode a set-profile-picture struct from an array.
     *
     * @param array Array to decode from.
     * @returns SetProfilePicture instance.
     */
    public static decode(array: Uint8Array): SetProfilePicture {
        return new SetProfilePicture(array);
    }

    /**
     * Encode a set-profile-picture struct into an array.
     *
     * @param struct SetProfilePictureEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<SetProfilePictureEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        const view = new DataView(array.buffer, array.byteOffset, array.byteLength);

        // Encode `picture-blob-id`
        utils.encodeBytes(struct.pictureBlobId, array, 0);

        // Encode `picture-size`
        view.setUint32(16, struct.pictureSize, true);

        // Encode `key`
        utils.encodeBytes(struct.key, array, 20);

        return array.subarray(0, 52);
    }

    /**
     * Get the amount of bytes that would be written when encoding a set-profile-picture struct into an
     * array.
     *
     * @param struct SetProfilePictureEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<SetProfilePictureEncodable, 'byteLength'>,
    ): types.u53 {
        return 52;
    }

    /**
     * 'picture-blob-id' field accessor. See {@link SetProfilePictureLike#pictureBlobId} for the
     * field's description.
     */
    public get pictureBlobId(): Uint8Array {
        const offset = 0;
        return this._array.subarray(offset, offset + 16);
    }

    /**
     * 'picture-size' field accessor. See {@link SetProfilePictureLike#pictureSize} for the
     * field's description.
     */
    public get pictureSize(): types.u32 {
        return this._view.getUint32(16, true);
    }

    /**
     * 'key' field accessor. See {@link SetProfilePictureLike#key} for the
     * field's description.
     */
    public get key(): Uint8Array {
        const offset = 20;
        return this._array.subarray(offset, offset + 32);
    }

    /**
     * Create a snapshot of SetProfilePictureLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns SetProfilePictureLike snapshot.
     */
    public snapshot(): SetProfilePictureLike {
        return {
            pictureBlobId: this.pictureBlobId,
            pictureSize: this.pictureSize,
            key: this.key,
        };
    }

    /**
     * Create a clone of SetProfilePictureLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns SetProfilePictureLike clone.
     */
    public clone(): SetProfilePicture {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new SetProfilePicture(array);
    }
}

/**
 * Delete the profile picture of a contact.
 *
 * **Flags:** None.
 *
 * **Delivery receipts:** Automatic: No. Manual: No.
 *
 * **User profile distribution:** No.
 *
 * **Reflect (contacts):** Incoming: No. Outgoing: No.
 *
 * **Reflect (groups):** Incoming: Yes. Outgoing: Yes.
 *
 * When receiving this message as a contact control message:
 *
 * 1. Remove the _contact-defined_ profile picture and run the _Contact
 *    Profile Picture Selection Steps_.
 *
 * When receiving this message as a group control message (wrapped by
 * [`group-creator-container`](ref:e2e.group-creator-container)):
 *
 * 1. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the
 *    message has been discarded, abort these steps.
 * 2. Remove the profile picture of the group.
 */
export interface DeleteProfilePictureLike {}

/**
 * Encodable of {@link DeleteProfilePictureLike}.
 */
interface DeleteProfilePictureEncodable_ {}

/**
 * New-type for DeleteProfilePictureEncodable.
 */
export type DeleteProfilePictureEncodable = types.WeakOpaque<
    DeleteProfilePictureEncodable_,
    {readonly DeleteProfilePictureEncodable: unique symbol}
>;

/** @inheritdoc */
export class DeleteProfilePicture extends base.Struct implements DeleteProfilePictureLike {
    private readonly _array: Uint8Array;

    /**
     * Create a DeleteProfilePicture from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a delete-profile-picture struct from an array.
     *
     * @param array Array to decode from.
     * @returns DeleteProfilePicture instance.
     */
    public static decode(array: Uint8Array): DeleteProfilePicture {
        return new DeleteProfilePicture(array);
    }

    /**
     * Encode a delete-profile-picture struct into an array.
     *
     * @param struct DeleteProfilePictureEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<DeleteProfilePictureEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        return array.subarray(0, 0);
    }

    /**
     * Get the amount of bytes that would be written when encoding a delete-profile-picture struct into an
     * array.
     *
     * @param struct DeleteProfilePictureEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<DeleteProfilePictureEncodable, 'byteLength'>,
    ): types.u53 {
        return 0;
    }

    /**
     * Create a snapshot of DeleteProfilePictureLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns DeleteProfilePictureLike snapshot.
     */
    public snapshot(): DeleteProfilePictureLike {
        return {};
    }

    /**
     * Create a clone of DeleteProfilePictureLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns DeleteProfilePictureLike clone.
     */
    public clone(): DeleteProfilePicture {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new DeleteProfilePicture(array);
    }
}

/**
 * Request a contact's profile picture.
 *
 * Note that this message does not result in the profile picture being sent
 * immediately in reply to this message. Instead, it will be sent the next
 * time that contact sends a message to the user (if one is set, and if the
 * user is eligible for receiving the profile picture).
 *
 * **Flags:** None.
 *
 * **Delivery receipts:** Automatic: No. Manual: No.
 *
 * **User profile distribution:** No.
 *
 * **Reflect:** Incoming: Yes. Outgoing: No.
 *
 * Send this when restoring a contact from a backup.
 *
 * When receiving this message via CSP or reflection:
 *
 * 1. Look up the sender contact. If the contact could not be found, abort
 *    these steps.
 * 2. If the sender is not eligible for reception of the profile picture,
 *    abort these steps.
 * 3. Clear the cached profile picture blob ID for the sender.
 */
export interface ContactRequestProfilePictureLike {}

/**
 * Encodable of {@link ContactRequestProfilePictureLike}.
 */
interface ContactRequestProfilePictureEncodable_ {}

/**
 * New-type for ContactRequestProfilePictureEncodable.
 */
export type ContactRequestProfilePictureEncodable = types.WeakOpaque<
    ContactRequestProfilePictureEncodable_,
    {readonly ContactRequestProfilePictureEncodable: unique symbol}
>;

/** @inheritdoc */
export class ContactRequestProfilePicture
    extends base.Struct
    implements ContactRequestProfilePictureLike
{
    private readonly _array: Uint8Array;

    /**
     * Create a ContactRequestProfilePicture from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a contact-request-profile-picture struct from an array.
     *
     * @param array Array to decode from.
     * @returns ContactRequestProfilePicture instance.
     */
    public static decode(array: Uint8Array): ContactRequestProfilePicture {
        return new ContactRequestProfilePicture(array);
    }

    /**
     * Encode a contact-request-profile-picture struct into an array.
     *
     * @param struct ContactRequestProfilePictureEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<ContactRequestProfilePictureEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        return array.subarray(0, 0);
    }

    /**
     * Get the amount of bytes that would be written when encoding a contact-request-profile-picture struct into an
     * array.
     *
     * @param struct ContactRequestProfilePictureEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<ContactRequestProfilePictureEncodable, 'byteLength'>,
    ): types.u53 {
        return 0;
    }

    /**
     * Create a snapshot of ContactRequestProfilePictureLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns ContactRequestProfilePictureLike snapshot.
     */
    public snapshot(): ContactRequestProfilePictureLike {
        return {};
    }

    /**
     * Create a clone of ContactRequestProfilePictureLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns ContactRequestProfilePictureLike clone.
     */
    public clone(): ContactRequestProfilePicture {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new ContactRequestProfilePicture(array);
    }
}

/**
 * Announces the group setup to all participants. The group creator is
 * always a member of the group and must not be included in the member
 * list.
 *
 * This is sent by the creator to create a new group, as well as update and
 * disband an existing group. The group creator sends this message to all
 * current (including those to be removed) and newly added group members.
 * The group creator may also send this to a single receiver in special
 * cases.
 *
 * Since the group creator is not allowed to leave the group, the only way
 * for it to stop being a member is by sending a `group-setup` with an
 * empty members list and thereby disbanding the group.
 *
 * **Flags:** None.
 *
 * **Delivery receipts:** Automatic: No. Manual: No.
 *
 * **User profile distribution:** Yes.
 *
 * **Reflect:** Incoming: Yes. Outgoing: Yes.
 *
 * When sending this message as a response to a single receiver, see the
 * handling logic that triggered this message for details. No further
 * steps are required.
 *
 * When sending this message to all group members:
 *
 * 1. If the user is not the creator of the group, abort these steps.
 * 2. Create a `group-setup` message with an empty members list and send it
 *    to the group members that are to be removed from the group.
 * 3. Let `members` be the current member list of the group. Remove all
 *    members from this list that are to be removed from the group. Add all
 *    members to this list that are to be added to the group. (i.e. this
 *    list represents the updated member set with all removed and added
 *    members.)
 * 4. For each member of `members`, create a contact with acquaintance level
 *    _group_ if not already present in the contact list.
 * 5. Create a `group-setup` message with the members present in
 *    `members`. Send this message to all group members present in
 *    `members`.
 * 6. For each newly added `member` in `members`,
 *    additionally:
 *    1. If the group has a profile picture, send a
 *       [`set-profile-picture`](ref:e2e.set-profile-picture) group control
 *       message to the newly added `member`.
 *    2. If the group has no profile picture, send a
 *       [`delete-profile-picture`](ref:e2e.delete-profile-picture) group
 *       control message to the newly added `member`.
 *    3. If a group call is currently considered running within this group,
 *       run the _Group Call Refresh Steps_ and let `chosen-call` be the
 *       result. If `chosen-call` is defined, repeat
 *       `csp-e2e.GroupCallStart` that is associated to `chosen-call` with
 *       the _created_ timestamp set to the `started_at` value associated to
 *       `chosen-call`.
 * 7. If the action of the user triggering these steps was to disband or
 *    delete the group (and consequently `members` is empty):
 *    1. If the user is currently participating in a group call of this
 *       group, trigger leaving the call.
 *    2. Mark the group as _left_ and abort these steps. Persist this
 *       mark even if the group and its history is being removed by the
 *       user. When disbanding but not deleting, the client should persist
 *       the previous member setup, ignoring the content of `member` to give
 *       the user the possibility to view the message history and the member
 *       setup prior to the user being removed. The user must not be able to
 *       send any more messages to the group but may be allowed to _reopen_
 *       the group with the previous member setup, when desired.
 * 8. Update the group with the given `members`.
 * 9. If the group was previously marked as _left_, remove the _left_ mark.
 *
 * When receiving this message as a group control message (wrapped by
 * [`group-creator-container`](ref:e2e.group-creator-container)):
 *
 * 1. Let `members` be the given member list. Remove all duplicate entries
 *    from `members`. Remove the sender from `members` if present.
 * 2. Look up the group.
 * 3. If the group could not be found:
 *    1. If the user is not present in `members`, abort these steps.
 *    2. If the sender is [blocked](ref:e2e#blocking), send a
 *    [`group-leave`](ref:e2e.group-leave) message to the sender and all
 *    provided `members` (including those who are
 *    [blocked](ref:e2e#blocking)) and abort these steps.
 * 4. If the group could be found and `members` is empty or does not include
 *    the user:
 *    1. If the user is currently participating in a group call of this
 *       group, trigger leaving the call.
 *    2. Mark the group as _left_ and abort these steps.
 *       Persist this mark even if the group and its history is being removed
 *       by the user. The client should persist the previous member setup,
 *       ignoring the content of `members` to give the user the possibility
 *       to view the message history and the member setup prior to the user
 *       being removed. The user must not be able to send any more messages
 *       to the group but should be able to clone the group with the previous
 *       member setup, when desired.
 * 5. For each member of `members`, create a contact with acquaintance
 *    level _group_ if not already present in the contact list. (Do not add
 *    the user's own identity as a contact.)
 * 6. Create or update the group with the given `members` plus the sender
 *    (creator).
 * 7. If the group was previously marked as _left_, remove the _left_ mark.
 * 8. If the user is currently participating in a group call of this group
 *    and there are group call participants which are no longer members of
 *    the group, remove these participants from the group call (handle them
 *    as if they left the call).
 */
export interface GroupSetupLike {
    /**
     * A set of Threema IDs defining group membership. The creator's
     * Threema ID is always inferred and must not be included in this set.
     */
    readonly members: Iterable<Uint8Array>;
}

/**
 * Encodable of {@link GroupSetupLike}.
 */
interface GroupSetupEncodable_ {
    /**
     * 'members' field value or encoder. See {@link GroupSetupLike#members} for
     * the field's description.
     */
    readonly members: types.BoundedIterable<Uint8Array | types.ByteLengthEncoder>;
}

/**
 * New-type for GroupSetupEncodable.
 */
export type GroupSetupEncodable = types.WeakOpaque<
    GroupSetupEncodable_,
    {readonly GroupSetupEncodable: unique symbol}
>;

/** @inheritdoc */
export class GroupSetup extends base.Struct implements GroupSetupLike {
    private readonly _array: Uint8Array;

    /**
     * Create a GroupSetup from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a group-setup struct from an array.
     *
     * @param array Array to decode from.
     * @returns GroupSetup instance.
     */
    public static decode(array: Uint8Array): GroupSetup {
        return new GroupSetup(array);
    }

    /**
     * Encode a group-setup struct into an array.
     *
     * @param struct GroupSetupEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<GroupSetupEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        let offset = 0;

        // Encode `members`
        offset += utils.encodeIterable(struct.members, offset, 8, (o, v) => {
            utils.encodeBytes(v, array, o);
        });

        return array.subarray(0, offset);
    }

    /**
     * Get the amount of bytes that would be written when encoding a group-setup struct into an
     * array.
     *
     * @param struct GroupSetupEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<GroupSetupEncodable, 'byteLength'>,
    ): types.u53 {
        let offset = 0;
        offset += struct.members.length * 8;
        return offset;
    }

    /**
     * 'members' field accessor. See {@link GroupSetupLike#members} for the
     * field's description.
     */
    public get members(): Iterable<Uint8Array> {
        return utils.decodeIterable(this._array, 0, 8, (o) => this._array.subarray(o, o + 8));
    }

    /**
     * Create a snapshot of GroupSetupLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns GroupSetupLike snapshot.
     */
    public snapshot(): GroupSetupLike {
        return {
            members: this.members,
        };
    }

    /**
     * Create a clone of GroupSetupLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns GroupSetupLike clone.
     */
    public clone(): GroupSetup {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new GroupSetup(array);
    }
}

/**
 * Name (or rename) a group. Sent to all group members when the group is
 * being created for the first time or the group is being renamed. May also
 * be sent to a single receiver as a response to a
 * [`group-sync-request`](ref:e2e.group-sync-request) message.
 *
 * **Flags:** None.
 *
 * **Delivery receipts:** Automatic: No. Manual: No.
 *
 * **User profile distribution:** Yes.
 *
 * **Reflect:** Incoming: Yes. Outgoing: Yes.
 *
 * When receiving this message as a group control message (wrapped by
 * [`group-creator-container`](ref:e2e.group-creator-container)):
 *
 * 1. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the
 *    message has been discarded, abort these steps.
 * 2. Update the group with the given name.
 */
export interface GroupNameLike {
    /**
     * UTF-8 encoded string containing the group's name.
     */
    readonly name: Uint8Array;
}

/**
 * Encodable of {@link GroupNameLike}.
 */
interface GroupNameEncodable_ {
    /**
     * 'name' field value or encoder. See {@link GroupNameLike#name} for
     * the field's description.
     */
    readonly name: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for GroupNameEncodable.
 */
export type GroupNameEncodable = types.WeakOpaque<
    GroupNameEncodable_,
    {readonly GroupNameEncodable: unique symbol}
>;

/** @inheritdoc */
export class GroupName extends base.Struct implements GroupNameLike {
    private readonly _array: Uint8Array;

    /**
     * Create a GroupName from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a group-name struct from an array.
     *
     * @param array Array to decode from.
     * @returns GroupName instance.
     */
    public static decode(array: Uint8Array): GroupName {
        return new GroupName(array);
    }

    /**
     * Encode a group-name struct into an array.
     *
     * @param struct GroupNameEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<GroupNameEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        let offset = 0;

        // Encode `name`
        offset += utils.encodeBytes(struct.name, array, offset);

        return array.subarray(0, offset);
    }

    /**
     * Get the amount of bytes that would be written when encoding a group-name struct into an
     * array.
     *
     * @param struct GroupNameEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<GroupNameEncodable, 'byteLength'>,
    ): types.u53 {
        let offset = 0;
        offset += utils.getByteLength(struct.name);
        return offset;
    }

    /**
     * 'name' field accessor. See {@link GroupNameLike#name} for the
     * field's description.
     */
    public get name(): Uint8Array {
        return this._array.subarray(0);
    }

    /**
     * Create a snapshot of GroupNameLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns GroupNameLike snapshot.
     */
    public snapshot(): GroupNameLike {
        return {
            name: this.name,
        };
    }

    /**
     * Create a clone of GroupNameLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns GroupNameLike clone.
     */
    public clone(): GroupName {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new GroupName(array);
    }
}

/**
 * Sent by a group member...
 *
 * * that is leaving the group. The message is sent to all other group
 *   members and the creator.
 * * in direct reply to a group message for a group that it has marked as
 *   left.
 *
 * Note: The group creator is not allowed to leave the group.
 *
 * **Flags:** None.
 *
 * **Delivery receipts:** Automatic: No. Manual: No.
 *
 * **User profile distribution:** No.
 *
 * **Reflect:** Incoming: Yes. Outgoing: Yes.
 *
 * When sending this message:
 *
 * 1. If the user is participating in a group call of this group, trigger
 *    leaving the call.
 * 2. Mark the group as _left_. Persist this mark
 *    even if the group and its history is being removed by the user. The
 *    client should persist the previous member setup of the group to give
 *    the user the possibility to view the message history and the member
 *    setup prior to the user leaving the group. The user must not be able to
 *    send any more messages to the group but should be able to clone the
 *    group with the previous member setup, when desired.
 *
 * When receiving this message as a group control message (wrapped by
 * [`group-member-container`](ref:e2e.group-member-container)):
 *
 * 1. If the sender is the creator of the group, discard the message and
 *    abort these steps.
 * 2. Look up the group.
 * 3. If the group could not be found or is marked as _left_:
 *     1. If the user is the creator of the group (as alleged by the
 *        message), discard the message and abort these steps.
 *     2. Send a [`group-sync-request`](ref:e2e.group-sync-request) to the
 *        group creator, discard the message and abort these steps.
 * 4. Remove the member from the local group.
 * 5. If the user and the sender are participating in a group call of this
 *    group, remove the sender from the group call (handle it as if the
 *    sender left the call).
 */
export interface GroupLeaveLike {}

/**
 * Encodable of {@link GroupLeaveLike}.
 */
interface GroupLeaveEncodable_ {}

/**
 * New-type for GroupLeaveEncodable.
 */
export type GroupLeaveEncodable = types.WeakOpaque<
    GroupLeaveEncodable_,
    {readonly GroupLeaveEncodable: unique symbol}
>;

/** @inheritdoc */
export class GroupLeave extends base.Struct implements GroupLeaveLike {
    private readonly _array: Uint8Array;

    /**
     * Create a GroupLeave from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a group-leave struct from an array.
     *
     * @param array Array to decode from.
     * @returns GroupLeave instance.
     */
    public static decode(array: Uint8Array): GroupLeave {
        return new GroupLeave(array);
    }

    /**
     * Encode a group-leave struct into an array.
     *
     * @param struct GroupLeaveEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<GroupLeaveEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        return array.subarray(0, 0);
    }

    /**
     * Get the amount of bytes that would be written when encoding a group-leave struct into an
     * array.
     *
     * @param struct GroupLeaveEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<GroupLeaveEncodable, 'byteLength'>,
    ): types.u53 {
        return 0;
    }

    /**
     * Create a snapshot of GroupLeaveLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns GroupLeaveLike snapshot.
     */
    public snapshot(): GroupLeaveLike {
        return {};
    }

    /**
     * Create a clone of GroupLeaveLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns GroupLeaveLike clone.
     */
    public clone(): GroupLeave {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new GroupLeave(array);
    }
}

/**
 * Sent by a group member (or a device assuming to be part of the group) to
 * the group creator.
 *
 * **Flags:** None.
 *
 * **Delivery receipts:** Automatic: No. Manual: No.
 *
 * **User profile distribution:** No.
 *
 * **Reflect:** Incoming: Yes. Outgoing: Yes.
 *
 * When receiving this message as a group control message (wrapped by
 * [`group-creator-container`](ref:e2e.group-creator-container)):
 *
 * 1. Look up the group. If the group could not be found, discard the message
 *    and abort these steps.
 * 2. If the group is marked as _left_ or the sender is not a member of the
 *    group, send a [`group-setup`](ref:e2e.group-setup) with an empty
 *    members list back to the sender and abort these steps.
 * 3. Send a [`group-setup`](ref:e2e.group-setup) message with the current
 *    group members, followed by a [`group-name`](ref:e2e.group-name)
 *    message to the sender.
 * 4. If the group has a profile picture, send a
 *    [`set-profile-picture`](ref:e2e.set-profile-picture) group control
 *    message to the sender.
 * 5. If the group has no profile picture, send a
 *    [`delete-profile-picture`](ref:e2e.delete-profile-picture) group
 *    control message to the sender.
 * 6. If a group call is currently considered running within this group,
 *    run the _Group Call Refresh Steps_ and let `chosen-call` be the result.
 *    If `chosen-call` is defined, repeat `csp-e2e.GroupCallStart` that is
 *    associated to `chosen-call` with the _created_ timestamp set to the
 *    `started_at` value associated to `chosen-call`.
 */
export interface GroupSyncRequestLike {}

/**
 * Encodable of {@link GroupSyncRequestLike}.
 */
interface GroupSyncRequestEncodable_ {}

/**
 * New-type for GroupSyncRequestEncodable.
 */
export type GroupSyncRequestEncodable = types.WeakOpaque<
    GroupSyncRequestEncodable_,
    {readonly GroupSyncRequestEncodable: unique symbol}
>;

/** @inheritdoc */
export class GroupSyncRequest extends base.Struct implements GroupSyncRequestLike {
    private readonly _array: Uint8Array;

    /**
     * Create a GroupSyncRequest from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a group-sync-request struct from an array.
     *
     * @param array Array to decode from.
     * @returns GroupSyncRequest instance.
     */
    public static decode(array: Uint8Array): GroupSyncRequest {
        return new GroupSyncRequest(array);
    }

    /**
     * Encode a group-sync-request struct into an array.
     *
     * @param struct GroupSyncRequestEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<GroupSyncRequestEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        return array.subarray(0, 0);
    }

    /**
     * Get the amount of bytes that would be written when encoding a group-sync-request struct into an
     * array.
     *
     * @param struct GroupSyncRequestEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<GroupSyncRequestEncodable, 'byteLength'>,
    ): types.u53 {
        return 0;
    }

    /**
     * Create a snapshot of GroupSyncRequestLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns GroupSyncRequestLike snapshot.
     */
    public snapshot(): GroupSyncRequestLike {
        return {};
    }

    /**
     * Create a clone of GroupSyncRequestLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns GroupSyncRequestLike clone.
     */
    public clone(): GroupSyncRequest {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new GroupSyncRequest(array);
    }
}
