// This file has been generated by structbuf. Do not modify it!
import * as base from '~/common/network/structbuf/base';
import type * as types from '~/common/types';
import * as utils from '../utils';

/**
 * ## Handshake
 *
 * To perform the authentication handshake, the following handshake structs
 * have to be exchanged in this order:
 *
 * - `rrd-hello`
 * - `rid-auth-hello`
 * - `rrd-auth`
 * - `nominate`
 *
 * Note that handshake structs have no framing container struct, so the
 * struct sizes are constant.
 *
 * ### Path Nomination
 *
 * After `rrd-auth` has been sent by RRD / validated by RID, the
 * authentication process is considered complete. The upper-level protocol
 * must define which of the peers is allowed to nominate the path.
 *
 * Once nomination occurred via the `nominate` struct, all other paths and
 * their associated connections are silently closed and the handshake process
 * is concluded.
 */

/**
 * Initial message from RRD containing its authentication challenge.
 *
 * Direction: RRD --> RID
 */
export interface RrdHelloLike {
    /**
     * 16 byte random path cookie used for nonces
     */
    readonly rrdck: Uint8Array;

    /**
     * Random authentication challenge (`rrd-challenge`), encrypted by:
     *
     *     Box(RK.secret)
     *       .encrypt(data=<rrd-challenge>, nonce=<RRDCK><RRDSN+>)
     */
    readonly rrdChallengeBox: Uint8Array;
}

/**
 * Encodable of {@link RrdHelloLike}.
 */
interface RrdHelloEncodable_ {
    /**
     * 'rrdck' field value or encoder. See {@link RrdHelloLike#rrdck} for
     * the field's description.
     */
    readonly rrdck: Uint8Array | types.ByteLengthEncoder;

    /**
     * 'rrd-challenge-box' field value or encoder. See {@link RrdHelloLike#rrdChallengeBox} for
     * the field's description.
     */
    readonly rrdChallengeBox: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for RrdHelloEncodable.
 */
export type RrdHelloEncodable = types.WeakOpaque<
    RrdHelloEncodable_,
    {readonly RrdHelloEncodable: unique symbol}
>;

/** @inheritdoc */
export class RrdHello extends base.Struct implements RrdHelloLike {
    private readonly _array: Uint8Array;

    /**
     * Create a RrdHello from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a rrd-hello struct from an array.
     *
     * @param array Array to decode from.
     * @returns RrdHello instance.
     */
    public static decode(array: Uint8Array): RrdHello {
        return new RrdHello(array);
    }

    /**
     * Encode a rrd-hello struct into an array.
     *
     * @param struct RrdHelloEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<RrdHelloEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        // Encode `rrdck`
        utils.encodeBytes(struct.rrdck, array, 0);

        // Encode `rrd-challenge-box`
        utils.encodeBytes(struct.rrdChallengeBox, array, 16);

        return array.subarray(0, 48);
    }

    /**
     * Get the amount of bytes that would be written when encoding a rrd-hello struct into an
     * array.
     *
     * @param struct RrdHelloEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<RrdHelloEncodable, 'byteLength'>,
    ): types.u53 {
        return 48;
    }

    /**
     * 'rrdck' field accessor. See {@link RrdHelloLike#rrdck} for the
     * field's description.
     */
    public get rrdck(): Uint8Array {
        const offset = 0;
        return this._array.subarray(offset, offset + 16);
    }

    /**
     * 'rrd-challenge-box' field accessor. See {@link RrdHelloLike#rrdChallengeBox} for the
     * field's description.
     */
    public get rrdChallengeBox(): Uint8Array {
        const offset = 16;
        return this._array.subarray(offset, offset + 32);
    }

    /**
     * Create a snapshot of RrdHelloLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns RrdHelloLike snapshot.
     */
    public snapshot(): RrdHelloLike {
        return {
            rrdck: this.rrdck,
            rrdChallengeBox: this.rrdChallengeBox,
        };
    }

    /**
     * Create a clone of RrdHelloLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns RrdHelloLike clone.
     */
    public clone(): RrdHello {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new RrdHello(array);
    }
}

/**
 * Authentication challenge from RRD.
 */
export interface RrdChallengeLike {
    /**
     * 16 byte random authentication challenge for RID
     */
    readonly rrdChallenge: Uint8Array;
}

/**
 * Encodable of {@link RrdChallengeLike}.
 */
interface RrdChallengeEncodable_ {
    /**
     * 'rrd-challenge' field value or encoder. See {@link RrdChallengeLike#rrdChallenge} for
     * the field's description.
     */
    readonly rrdChallenge: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for RrdChallengeEncodable.
 */
export type RrdChallengeEncodable = types.WeakOpaque<
    RrdChallengeEncodable_,
    {readonly RrdChallengeEncodable: unique symbol}
>;

/** @inheritdoc */
export class RrdChallenge extends base.Struct implements RrdChallengeLike {
    private readonly _array: Uint8Array;

    /**
     * Create a RrdChallenge from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a rrd-challenge struct from an array.
     *
     * @param array Array to decode from.
     * @returns RrdChallenge instance.
     */
    public static decode(array: Uint8Array): RrdChallenge {
        return new RrdChallenge(array);
    }

    /**
     * Encode a rrd-challenge struct into an array.
     *
     * @param struct RrdChallengeEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<RrdChallengeEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        // Encode `rrd-challenge`
        utils.encodeBytes(struct.rrdChallenge, array, 0);

        return array.subarray(0, 16);
    }

    /**
     * Get the amount of bytes that would be written when encoding a rrd-challenge struct into an
     * array.
     *
     * @param struct RrdChallengeEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<RrdChallengeEncodable, 'byteLength'>,
    ): types.u53 {
        return 16;
    }

    /**
     * 'rrd-challenge' field accessor. See {@link RrdChallengeLike#rrdChallenge} for the
     * field's description.
     */
    public get rrdChallenge(): Uint8Array {
        const offset = 0;
        return this._array.subarray(offset, offset + 16);
    }

    /**
     * Create a snapshot of RrdChallengeLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns RrdChallengeLike snapshot.
     */
    public snapshot(): RrdChallengeLike {
        return {
            rrdChallenge: this.rrdChallenge,
        };
    }

    /**
     * Create a clone of RrdChallengeLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns RrdChallengeLike clone.
     */
    public clone(): RrdChallenge {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new RrdChallenge(array);
    }
}

/**
 * Initial message from RID responding to RRD's authentication challenge
 * and containing RID's authentication challenge.
 *
 * Direction: RRD <-- RID
 *
 * When creating this message:
 *
 * 1. Ensure that RRDCK and RIDCK are not equal.
 * 2. Ensure that the random challenges from RID and RRD are not equal.
 *
 * When receiving this message:
 *
 * 1. If RRDCK or RIDCK are equal, abort the connection and these steps.
 * 2. If the challenge response from RID does not match the challenge sent
 *    by RRD, abort the connection and these steps.
 * 3. If the challenges from RID and RRD are equal, abort the connection
 *    and these steps.
 */
export interface RidAuthHelloLike {
    /**
     * 16 byte random path cookie used for nonces
     */
    readonly ridck: Uint8Array;

    /**
     * Random authentication challenge and challenge response
     * (`rid-challenge-and-response`), encrypted by:
     *
     *     Box(RK.secret).encrypt(
     *       data=<rid-challenge-and-response>,
     *       nonce=<RIDCK><RIDSN+>
     *     )
     */
    readonly ridChallengeAndResponseBox: Uint8Array;
}

/**
 * Encodable of {@link RidAuthHelloLike}.
 */
interface RidAuthHelloEncodable_ {
    /**
     * 'ridck' field value or encoder. See {@link RidAuthHelloLike#ridck} for
     * the field's description.
     */
    readonly ridck: Uint8Array | types.ByteLengthEncoder;

    /**
     * 'rid-challenge-and-response-box' field value or encoder. See {@link RidAuthHelloLike#ridChallengeAndResponseBox} for
     * the field's description.
     */
    readonly ridChallengeAndResponseBox: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for RidAuthHelloEncodable.
 */
export type RidAuthHelloEncodable = types.WeakOpaque<
    RidAuthHelloEncodable_,
    {readonly RidAuthHelloEncodable: unique symbol}
>;

/** @inheritdoc */
export class RidAuthHello extends base.Struct implements RidAuthHelloLike {
    private readonly _array: Uint8Array;

    /**
     * Create a RidAuthHello from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a rid-auth-hello struct from an array.
     *
     * @param array Array to decode from.
     * @returns RidAuthHello instance.
     */
    public static decode(array: Uint8Array): RidAuthHello {
        return new RidAuthHello(array);
    }

    /**
     * Encode a rid-auth-hello struct into an array.
     *
     * @param struct RidAuthHelloEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<RidAuthHelloEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        // Encode `ridck`
        utils.encodeBytes(struct.ridck, array, 0);

        // Encode `rid-challenge-and-response-box`
        utils.encodeBytes(struct.ridChallengeAndResponseBox, array, 16);

        return array.subarray(0, 64);
    }

    /**
     * Get the amount of bytes that would be written when encoding a rid-auth-hello struct into an
     * array.
     *
     * @param struct RidAuthHelloEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<RidAuthHelloEncodable, 'byteLength'>,
    ): types.u53 {
        return 64;
    }

    /**
     * 'ridck' field accessor. See {@link RidAuthHelloLike#ridck} for the
     * field's description.
     */
    public get ridck(): Uint8Array {
        const offset = 0;
        return this._array.subarray(offset, offset + 16);
    }

    /**
     * 'rid-challenge-and-response-box' field accessor. See {@link RidAuthHelloLike#ridChallengeAndResponseBox} for the
     * field's description.
     */
    public get ridChallengeAndResponseBox(): Uint8Array {
        const offset = 16;
        return this._array.subarray(offset, offset + 48);
    }

    /**
     * Create a snapshot of RidAuthHelloLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns RidAuthHelloLike snapshot.
     */
    public snapshot(): RidAuthHelloLike {
        return {
            ridck: this.ridck,
            ridChallengeAndResponseBox: this.ridChallengeAndResponseBox,
        };
    }

    /**
     * Create a clone of RidAuthHelloLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns RidAuthHelloLike clone.
     */
    public clone(): RidAuthHello {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new RidAuthHello(array);
    }
}

/**
 * Authentication challenge and challenge response from RID.
 */
export interface RidChallengeAndResponseLike {
    /**
     * 16 byte repeated authentication challenge from RRD
     */
    readonly rrdResponse: Uint8Array;

    /**
     * 16 byte random authentication challenge for RRD
     */
    readonly ridChallenge: Uint8Array;
}

/**
 * Encodable of {@link RidChallengeAndResponseLike}.
 */
interface RidChallengeAndResponseEncodable_ {
    /**
     * 'rrd-response' field value or encoder. See {@link RidChallengeAndResponseLike#rrdResponse} for
     * the field's description.
     */
    readonly rrdResponse: Uint8Array | types.ByteLengthEncoder;

    /**
     * 'rid-challenge' field value or encoder. See {@link RidChallengeAndResponseLike#ridChallenge} for
     * the field's description.
     */
    readonly ridChallenge: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for RidChallengeAndResponseEncodable.
 */
export type RidChallengeAndResponseEncodable = types.WeakOpaque<
    RidChallengeAndResponseEncodable_,
    {readonly RidChallengeAndResponseEncodable: unique symbol}
>;

/** @inheritdoc */
export class RidChallengeAndResponse extends base.Struct implements RidChallengeAndResponseLike {
    private readonly _array: Uint8Array;

    /**
     * Create a RidChallengeAndResponse from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a rid-challenge-and-response struct from an array.
     *
     * @param array Array to decode from.
     * @returns RidChallengeAndResponse instance.
     */
    public static decode(array: Uint8Array): RidChallengeAndResponse {
        return new RidChallengeAndResponse(array);
    }

    /**
     * Encode a rid-challenge-and-response struct into an array.
     *
     * @param struct RidChallengeAndResponseEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<RidChallengeAndResponseEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        // Encode `rrd-response`
        utils.encodeBytes(struct.rrdResponse, array, 0);

        // Encode `rid-challenge`
        utils.encodeBytes(struct.ridChallenge, array, 16);

        return array.subarray(0, 32);
    }

    /**
     * Get the amount of bytes that would be written when encoding a rid-challenge-and-response struct into an
     * array.
     *
     * @param struct RidChallengeAndResponseEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<RidChallengeAndResponseEncodable, 'byteLength'>,
    ): types.u53 {
        return 32;
    }

    /**
     * 'rrd-response' field accessor. See {@link RidChallengeAndResponseLike#rrdResponse} for the
     * field's description.
     */
    public get rrdResponse(): Uint8Array {
        const offset = 0;
        return this._array.subarray(offset, offset + 16);
    }

    /**
     * 'rid-challenge' field accessor. See {@link RidChallengeAndResponseLike#ridChallenge} for the
     * field's description.
     */
    public get ridChallenge(): Uint8Array {
        const offset = 16;
        return this._array.subarray(offset, offset + 16);
    }

    /**
     * Create a snapshot of RidChallengeAndResponseLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns RidChallengeAndResponseLike snapshot.
     */
    public snapshot(): RidChallengeAndResponseLike {
        return {
            rrdResponse: this.rrdResponse,
            ridChallenge: this.ridChallenge,
        };
    }

    /**
     * Create a clone of RidChallengeAndResponseLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns RidChallengeAndResponseLike clone.
     */
    public clone(): RidChallengeAndResponse {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new RidChallengeAndResponse(array);
    }
}

/**
 * Challenge response to RID's authentication challenge.
 *
 * Direction: RRD --> RID
 *
 * When receiving this message:
 *
 * 1. If the challenge response from RRD does not match the challenge sent
 *    by RID, abort the connection and these steps.
 */
export interface RrdAuthLike {
    /**
     * Challenge response (`rrd-response`), encrypted by:
     *
     *     Box(RK.secret)
     *       .encrypt(data=<rrd-response>, nonce=<RRDCK><RRDSN+>)
     */
    readonly challengeAndResponseBox: Uint8Array;
}

/**
 * Encodable of {@link RrdAuthLike}.
 */
interface RrdAuthEncodable_ {
    /**
     * 'challenge-and-response-box' field value or encoder. See {@link RrdAuthLike#challengeAndResponseBox} for
     * the field's description.
     */
    readonly challengeAndResponseBox: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for RrdAuthEncodable.
 */
export type RrdAuthEncodable = types.WeakOpaque<
    RrdAuthEncodable_,
    {readonly RrdAuthEncodable: unique symbol}
>;

/** @inheritdoc */
export class RrdAuth extends base.Struct implements RrdAuthLike {
    private readonly _array: Uint8Array;

    /**
     * Create a RrdAuth from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a rrd-auth struct from an array.
     *
     * @param array Array to decode from.
     * @returns RrdAuth instance.
     */
    public static decode(array: Uint8Array): RrdAuth {
        return new RrdAuth(array);
    }

    /**
     * Encode a rrd-auth struct into an array.
     *
     * @param struct RrdAuthEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<RrdAuthEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        // Encode `challenge-and-response-box`
        utils.encodeBytes(struct.challengeAndResponseBox, array, 0);

        return array.subarray(0, 32);
    }

    /**
     * Get the amount of bytes that would be written when encoding a rrd-auth struct into an
     * array.
     *
     * @param struct RrdAuthEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(struct: types.EncoderPick<RrdAuthEncodable, 'byteLength'>): types.u53 {
        return 32;
    }

    /**
     * 'challenge-and-response-box' field accessor. See {@link RrdAuthLike#challengeAndResponseBox} for the
     * field's description.
     */
    public get challengeAndResponseBox(): Uint8Array {
        const offset = 0;
        return this._array.subarray(offset, offset + 32);
    }

    /**
     * Create a snapshot of RrdAuthLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns RrdAuthLike snapshot.
     */
    public snapshot(): RrdAuthLike {
        return {
            challengeAndResponseBox: this.challengeAndResponseBox,
        };
    }

    /**
     * Create a clone of RrdAuthLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns RrdAuthLike clone.
     */
    public clone(): RrdAuth {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new RrdAuth(array);
    }
}

/**
 * Authentication challenge response from RRD.
 */
export interface RrdResponseLike {
    /**
     * 16 byte repeated authentication challenge from RID
     */
    readonly ridResponse: Uint8Array;
}

/**
 * Encodable of {@link RrdResponseLike}.
 */
interface RrdResponseEncodable_ {
    /**
     * 'rid-response' field value or encoder. See {@link RrdResponseLike#ridResponse} for
     * the field's description.
     */
    readonly ridResponse: Uint8Array | types.ByteLengthEncoder;
}

/**
 * New-type for RrdResponseEncodable.
 */
export type RrdResponseEncodable = types.WeakOpaque<
    RrdResponseEncodable_,
    {readonly RrdResponseEncodable: unique symbol}
>;

/** @inheritdoc */
export class RrdResponse extends base.Struct implements RrdResponseLike {
    private readonly _array: Uint8Array;

    /**
     * Create a RrdResponse from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a rrd-response struct from an array.
     *
     * @param array Array to decode from.
     * @returns RrdResponse instance.
     */
    public static decode(array: Uint8Array): RrdResponse {
        return new RrdResponse(array);
    }

    /**
     * Encode a rrd-response struct into an array.
     *
     * @param struct RrdResponseEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<RrdResponseEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        // Encode `rid-response`
        utils.encodeBytes(struct.ridResponse, array, 0);

        return array.subarray(0, 16);
    }

    /**
     * Get the amount of bytes that would be written when encoding a rrd-response struct into an
     * array.
     *
     * @param struct RrdResponseEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<RrdResponseEncodable, 'byteLength'>,
    ): types.u53 {
        return 16;
    }

    /**
     * 'rid-response' field accessor. See {@link RrdResponseLike#ridResponse} for the
     * field's description.
     */
    public get ridResponse(): Uint8Array {
        const offset = 0;
        return this._array.subarray(offset, offset + 16);
    }

    /**
     * Create a snapshot of RrdResponseLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns RrdResponseLike snapshot.
     */
    public snapshot(): RrdResponseLike {
        return {
            ridResponse: this.ridResponse,
        };
    }

    /**
     * Create a clone of RrdResponseLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns RrdResponseLike clone.
     */
    public clone(): RrdResponse {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new RrdResponse(array);
    }
}

/**
 * Nominates a path. Which peer is allowed to nominate the path must be
 * defined by the upper-level protocol.
 *
 * Direction: RRD <-> RID
 *
 * When sending or receiving this message:
 *
 * 1. Silently close all other pending or established connection paths.
 */
export interface NominateLike {}

/**
 * Encodable of {@link NominateLike}.
 */
interface NominateEncodable_ {}

/**
 * New-type for NominateEncodable.
 */
export type NominateEncodable = types.WeakOpaque<
    NominateEncodable_,
    {readonly NominateEncodable: unique symbol}
>;

/** @inheritdoc */
export class Nominate extends base.Struct implements NominateLike {
    private readonly _array: Uint8Array;

    /**
     * Create a Nominate from an array for accessing properties.
     *
     * Note: When accessing, attributes will be decoded on-the-fly which may be expensive.
     */
    private constructor(array: Uint8Array) {
        super();
        this._array = array;
    }

    /**
     * Decode a nominate struct from an array.
     *
     * @param array Array to decode from.
     * @returns Nominate instance.
     */
    public static decode(array: Uint8Array): Nominate {
        return new Nominate(array);
    }

    /**
     * Encode a nominate struct into an array.
     *
     * @param struct NominateEncodable to encode.
     * @param array Array to encode into.
     * @returns A subarray of array containing the encoded struct.
     */
    public static encode(
        struct: types.EncoderPick<NominateEncodable, 'encode'>,
        array: Uint8Array,
    ): Uint8Array {
        return array.subarray(0, 0);
    }

    /**
     * Get the amount of bytes that would be written when encoding a nominate struct into an
     * array.
     *
     * @param struct NominateEncodable to encode.
     * @returns The amount of bytes that would be required to encode the struct.
     */
    public static byteLength(
        struct: types.EncoderPick<NominateEncodable, 'byteLength'>,
    ): types.u53 {
        return 0;
    }

    /**
     * Create a snapshot of NominateLike.
     *
     * Note: This is **not** a deep-copy, so byte arrays will still be views of the underlying
     *       buffer.
     *
     * @returns NominateLike snapshot.
     */
    public snapshot(): NominateLike {
        return {};
    }

    /**
     * Create a clone of NominateLike.
     *
     * Note: This is a deep-copy that will copy the underlying buffer.
     *
     * @returns NominateLike clone.
     */
    public clone(): Nominate {
        const array = new Uint8Array(this._array.byteLength);
        array.set(this._array);
        return new Nominate(array);
    }
}
