@startuml
queue WebSocket
participant "1: Frame Layer" as 1
participant "2: Multiplex Layer" as 2
participant "3: Authentication and Transport Encryption Layer" as 3
participant "4: Connection Monitoring and Keepalive Layer" as 4
participant "5: End-to-End Layer" as 5

box "Task Manager" #LightBlue
queue "DecodeQueue" as TaskManagerDecodeQueue
control TaskManager



create TaskManagerDecodeQueue
TaskManager -> TaskManagerDecodeQueue: exposes

end box

note over WebSocket: Mediator Socket
/ note over 3: Handle CSP and D2M handshakes\n\t=>authentication state \nCSP transport encryption
/ note over 4: Send CSP echo requests and wait for replies
/ note over TaskManager: Process message\nhandle transactions\nhandle queues

== Decoding ==

note over 1: Decode bytes to d2m.container
/ note over 2: Demultiplex d2m.container to either\na D2M (protobuf) message, or\na CSP frame (type depending on auth state)
/ note over 3: CSP transport decryption\nDecode post-auth CSP payloads\nForward D2M messages
/ note over 5: Dispatch messages to\nTaskManager decode queue


WebSocket -> 1: ArrayBuffer
activate WebSocket
activate 1
1 -> 2: InboundL1Message
activate 2
2 -> 3: InboundL2Message
activate 3
3 -> 4: InboundL3Message
activate 4
4 -> 5: InboundL4Message
activate 5
5 -> TaskManagerDecodeQueue: InboundTaskMessage

deactivate WebSocket
deactivate 1
deactivate 2
deactivate 3
deactivate 4
deactivate 5

TaskManagerDecodeQueue <- TaskManager: Fetch Message (blocking)
return InboundTaskMessage

@enduml
